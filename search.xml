<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS学习笔记</title>
      <link href="/2023/05/23/JS%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/05/23/JS%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h1><h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>当一个函数被创建时，JS会给他内部自动添加一个属性：prototype，prototype为一个对象，其中有一个constructor指向创建的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230401160332850.png" alt="image-20230401160332850"></p><p>可以看到fn的prototype属性中有constructor属性，可以将其看作指针，它指向的是fn这个函数。</p><h2 id="构造函数和实例对象"><a href="#构造函数和实例对象" class="headerlink" title="构造函数和实例对象"></a>构造函数和实例对象</h2><p>一般来说，函数名首字母大写的函数称为构造函数。使用<strong>new关键字</strong>可以通过构造函数定义一个它的实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">info</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">name</span>);<span class="comment">//张三</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">age</span>);<span class="comment">//18</span></span><br><span class="line">fn.<span class="title function_">info</span>()<span class="comment">//张三，18</span></span><br></pre></td></tr></table></figure><p>此时fn就是Fn的<strong>实例对象</strong>。</p><p>fn会继承在Fn的所有属性，在new的过程中，Fn中的this会自动指向fn，所以在new的过程中，JS做了以下事情。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.<span class="property">__proto__</span> = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="title function_">call</span>(fn);</span><br></pre></td></tr></table></figure><h2 id="proto-和prototype"><a href="#proto-和prototype" class="headerlink" title="______proto______和prototype"></a>______proto______和prototype</h2><p>在每个构造函数的实例对象中都有**____<strong>proto</strong><strong>属性,此时也可以把它当作一个</strong>指针**，它所指向的就是构造函数的prototype对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">__proto__</span> === <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230401161816468.png" alt="image-20230401161816468"></p><p>此时fn就可以通过**____<strong>proto</strong><strong>获取Fn的</strong>prototype**原型上的所有属性。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>刚刚说到，通过**____<strong>proto</strong><strong>获取Fn的</strong>prototype<strong>原型上的所有属性,prototype也是一个实例对象，它是</strong>Object**的实例对象，因此在prototype中也有______proto__属性，它指向的是Object函数的原型对象，即Object的prototype原型对象。</p><p>既然prototype是一个实例对象，那么只要是实例对象，都会有一个**____<strong>proto</strong><strong>指向它的构造函数的原型对象。而Object的prototype的______proto______所指向的为</strong>null**。根据定义，null没有原型，因此原型链的尽头为Object.prototype.______proto__。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">info</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">__proto__</span> === <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)<span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>查找一个属性，实例对象会先在自身寻找，如果没有，会去它的______proto______也就是构造函数的prototype原型上找,如果也没有，则去构造函数的prototype的______proto__，也就是Object.prototype中去找，如果也没有，则返回undefined。</p><p>综上整个过程，即为原型链。</p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230401193449120.png" alt="image-20230401193449120"></p><h2 id="Function、Object、function"><a href="#Function、Object、function" class="headerlink" title="Function、Object、function"></a>Function、Object、function</h2><p>其实在构造函数中，也有一个______proto__，这是为什么呢？</p><p>因为构造函数是函数，而所有函数都是Function的实例（包括Function本身），所以就会有一个很有意思的现象。Function的______proto__指向Function的prototype原型对象。</p><p>而Object也是一个构造函数，它的______proto__指向Function的prototype。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ff422e52ff0f49df80984d36ee01c719.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjUwNTg0NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>then函数是由返回值的，返回的是一个<strong>新的Promise对象实例化对象</strong>。</p><p>如果p1实例化对象是<strong>成功的状态</strong>，则<strong>执行then的成功回调函数</strong>；如果是<strong>失败</strong>的状态，则<strong>执行then的失败的回调函数</strong>。</p><p><strong>如果then中没有返回值</strong></p><ul><li>​then函数返回的Promise是<strong>成功</strong>的状态，并且<strong>结果值是undefined</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve(2)</span></span><br><span class="line">    <span class="comment">// reject(1)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;err&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230518193023372.png" alt="image-20230518193023372"></p><p><strong>如果then中有返回值</strong></p><ol><li>返回的为<strong>非Promise实例化对象</strong>，则<strong>状态仍是成功的Promise实例化对象</strong>，<strong>返回值就是结果值</strong></li><li>返回的为<strong>Promise实例化对象</strong>，则<strong>p2的状态取决于Promise实例化对象的状态</strong></li><li>如果<strong>直接抛出异常</strong>，则返回失败的Promise</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve(2)</span></span><br><span class="line">    <span class="comment">// reject(1)</span></span><br><span class="line">    <span class="comment">// throw &quot;err&quot;</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;okok&quot;</span>;<span class="comment">//p2的状态 [[PromiseState]]: &quot;fulfilled&quot;  [[PromiseResult]]: okok</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_,reject</span>)=&gt;</span>&#123; <span class="comment">//p2的状态 [[PromiseState]]: &quot;rejected&quot;  [[PromiseResult]]: 1</span></span><br><span class="line">         <span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;err&quot;</span>  <span class="comment">//p2的状态 [[PromiseState]]: &quot;rejected&quot;  [[PromiseResult]]: err</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//如果p2没有返回值，则p2的状态 [[PromiseState]]: &quot;fulfilled&quot;[[PromiseResult]]: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 === p2)<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>如果then中省略或者不是一个回调函数</strong></p><ul><li>默认成功的回调函数为<code>value =&gt; value</code>,默认失败的回调函数为<code>reason =&gt; &#123;throw reason&#125;</code></li></ul><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>catch用于捕捉Promise里reject后的值，和then一样也返回一个新的Promise。<strong>只有一个回调函数，表示失败的回调。</strong></p><p><strong>如果catch中没有返回值</strong></p><ul><li>​catch函数返回的Promise是<strong>成功</strong>的状态，并且<strong>结果值是undefined</strong>。</li></ul><p><strong>如果catch中有返回值</strong></p><ol><li>返回的为<strong>非Promise实例化对象</strong>，则<strong>状态仍是成功的Promise实例化对象</strong>，<strong>返回值就是结果值</strong></li><li>返回的为<strong>Promise实例化对象</strong>，则<strong>p2的状态取决于Promise实例化对象的状态</strong></li><li>如果<strong>直接抛出异常</strong>，则返回失败的Promise</li></ol><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p><code>Promise.resolve()</code>返回一个Promise。可以进行传参。</p><ol><li>参数为<strong>非Promise或为空</strong>： Promise状态为fulfilled，结果为传进的参数或undefined</li><li>参数为<strong>Promise的实例对象</strong>，则返回的Promise的状态取决于Promise实力对象的状态。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);<span class="comment">//PromiseState fulfilled PromiseResult undefined  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//PromiseState fulfilled PromiseResult 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//PromiseState fulfilled PromiseResult 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);<span class="comment">//PromiseState rejected PromiseResult error </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p4);<span class="comment">//PromiseState rejected PromiseResult &#x27;异常&#x27; </span></span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>不管参数如何，都返回一个失败的Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);<span class="comment">//PromiseState rejected PromiseResult undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//PromiseState rejected PromiseResult 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//PromiseState rejected PromiseResult Promise </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);<span class="comment">//PromiseState rejected PromiseResult Promise </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p4);<span class="comment">//PromiseState rejected PromiseResult Promise </span></span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>需要传递一个<strong>数组</strong>参数，数组里存的是<strong>Promise的实例化对象</strong>，<strong>返回值</strong>也是<strong>Promise的实例化对象</strong>。</p><h3 id="返回值的Promise状态"><a href="#返回值的Promise状态" class="headerlink" title="返回值的Promise状态"></a>返回值的Promise状态</h3><ol><li>当数组中所有的Promise实例化对象的状态<strong>都是成功</strong>的话，则返回的Promise的状态也是<strong>成功</strong>的，结果值为<strong>所有成功的Promise实例化对象的结果组成的数组</strong></li><li>当数组中所有的Promise实例化对象的状态<strong>有一个失败</strong>的话，<strong>直接返回失败的Promise实例化对象</strong>，<strong>结果值</strong>就是<strong>第一个失败Promise实例化对象的结果值</strong>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve(2)</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">MyPromise</span>.<span class="title function_">all</span>([p1,p2,p3]);<span class="comment">//PromiseState rejected PromiseResult 1 </span></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">MyPromise</span>.<span class="title function_">all</span>([p1,p2,p4]);<span class="comment">//PromiseState fulfilled PromiseResult [1,3,4] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>参数为一个<strong>由多个Promise实例对象组成的数组</strong>。</p><p>返回一个新的Promise实例对象，状态取决于数组中<strong>最先改变状态</strong>的Promise实例对象的<strong>状态为准</strong>。</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>当<code>new Promise</code>链式调用时，每调用一个then都会产生一个新的Promise，它的状态只要不是抛出异常<code>throw error</code>以及在then的回调里返回一个失败的Promise，它都会是一个成功的Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//1</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="literal">null</span>,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">//error</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">// 不输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="异常穿透"><a href="#异常穿透" class="headerlink" title="异常穿透"></a>异常穿透</h3><p>当Promise的链式调用时出现异常，那么它会一直往下，直到遇到能处理异常的回调(<strong>then中的onrejected回调或catch</strong>),在此期间，then返回的Promise状态都是rejected，直到异常处理后才变成fulfilled。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// reject(1)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;异常&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//PromiseState rejected PromiseResult ’异常‘</span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//不输出</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//PromiseState rejected PromiseResult ’异常‘</span></span><br><span class="line"><span class="keyword">const</span> p3 = p2.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//不输出</span></span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);<span class="comment">//异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);<span class="comment">//PromiseState fulfilled PromiseResult 1  </span></span><br><span class="line"><span class="keyword">const</span> p4 = p3.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p4);<span class="comment">//PromiseState fulfilled PromiseResult undefined </span></span><br></pre></td></tr></table></figure><h2 id="中断Promise链"><a href="#中断Promise链" class="headerlink" title="中断Promise链"></a>中断Promise链</h2><p>只要在链式调用的过程中<strong>返回一个pending状态的Promise</strong>，Promise链就会中断。因为pending状态的Promise并没有处理，then处理成功或者失败的Promise，catch处理失败的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = p2.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p4 = p3.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//不输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="async函数和await表达式"><a href="#async函数和await表达式" class="headerlink" title="async函数和await表达式"></a>async函数和await表达式</h1><p>$\textcolor{red}{注意点：}$</p><ol><li>async函数中不一定要有await表达式，但有await的函数一定要有async</li><li>await相当于then，获取Promise实例对象成功的结果</li></ol><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>在函数前面加一个async就可以把该函数变为异步函数。</p><p>在函数内部正常书写，$\textcolor{red}{async函数的返回值为一个Promise}$ ,状态根据返回的数据决定。</p><ol><li>返回的是一个<strong>非Promise类型</strong>，那么状态为<strong>成功</strong>的Promise，结果为<strong>返回的具体值</strong>。</li><li>返回的是一个<strong>Promise实例对象</strong>，返回的Promise即为async函数返回的Promise。</li><li><strong>抛出异常</strong>，那么async也会返回一个<strong>失败的Promise</strong>，结果值为异常的值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="title function_">fn2</span>();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f3 = <span class="title function_">fn3</span>();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn4</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f4 = <span class="title function_">fn4</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1);<span class="comment">//PromiseState fulfilled PromiseResult 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2);<span class="comment">//PromiseState fulfilled PromiseResult 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f3);<span class="comment">//PromiseState rejected PromiseResult 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f4);<span class="comment">//PromiseState rejected PromiseResult &quot;异常&quot;</span></span><br></pre></td></tr></table></figure><h2 id="await（异步）"><a href="#await（异步）" class="headerlink" title="await（异步）"></a>await（异步）</h2><ol><li>如果await右侧为<strong>非Promise类型的数据</strong>，awiat后面<strong>是什么，得到的结果就是什么</strong></li><li>如果await右侧为<strong>成功的Promise</strong>，则得到的就是<strong>成功的结果</strong></li><li>如果await右侧为<strong>失败的Promise</strong>，需要用<strong>try…catch</strong>去捕获失败的结果</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn5</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(re);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn5</span>();<span class="comment">//null</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn6</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(re);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn6</span>();<span class="comment">//1</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn7</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="number">2</span>)<span class="comment">//失败的Promise需要用try...catch去捕获</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(re);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn7</span>();<span class="comment">//err</span></span><br></pre></td></tr></table></figure><h2 id="await执行顺序"><a href="#await执行顺序" class="headerlink" title="await执行顺序"></a>await执行顺序</h2><p>同步和异步同时存在时，会优先执行同步代码，随后再执行异步。<strong>await是异步的，它会等待后面的结果，哪怕是0秒也会等待。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> re1 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);<span class="comment">//await返回的是定时器的唯一标识符，timerId</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;re&quot;</span> + re);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//1 2 6 3 re4 5 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记</title>
      <link href="/2023/04/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.比特位计数</h1><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：[0,1,1]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：[0,1,1,2,1,2]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></table></figure><h3 id="使用Brian-Kernighan-（比特计算）算法"><a href="#使用Brian-Kernighan-（比特计算）算法" class="headerlink" title="使用Brian Kernighan （比特计算）算法"></a>使用Brian Kernighan （比特计算）算法</h3><p>使用<strong><em>x &#x3D; x&amp;(x-1</em>)<strong>可以将x的二进制数减少一个1，使用循环</strong>将计数变量递增</strong>计算1的个数即可。</p><p>解题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        arr[i] = <span class="title function_">counts</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">counts</span>(<span class="params">i</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        i = i &amp; (i-<span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.找到所有数组中消失的数字</h1><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">输出：[5,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p>思路：我的思路是使用includes从1到n(数组长度)进行判断，如果不包含，则直接数字i存入新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDisappearedNumbers = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> newNums = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.<span class="title function_">includes</span>(i))&#123;</span><br><span class="line">            newNums.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方题解：遍历数组，使用<strong>范围之外的数字</strong>来表示存在在数组nums中的数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDisappearedNumbers = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = (num - <span class="number">1</span>) % n; <span class="comment">//这里的n-1代表在序列数组中num本来应该所在的序号，因为num的范围是从1开始的。%n是为了避免碰到重复的数字，num已经加过n了。这样到最后，只有没有出现的数字所在的序号不会被加n。</span></span><br><span class="line">        nums[x] += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="comment">//nums.entries()是生成nums的键值队，[0,]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [i, num] <span class="keyword">of</span> nums.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">            ret.<span class="title function_">push</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">链接：<span class="attr">https</span>:<span class="comment">//leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/solutions/601946/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例 </span><br><span class="line">for (const num of nums) &#123;</span><br><span class="line">    const x = (num - 1) % n;</span><br><span class="line">    nums[x] += n;</span><br><span class="line">&#125;</span><br><span class="line">原数组 4,3,2,7,8,2,3,1     </span><br><span class="line">第一次交换  num = 4 x=34,3,2,15,8,2,3,1      </span><br><span class="line">第二次交换  num = 3x=24,3,10,15,8,2,3,1     </span><br><span class="line">第三次交换  num = 10 x=14,11,10,15,8,2,3,1   </span><br><span class="line">第四次交换  num = 15x=64,11,10,15,8,2,11,1          </span><br><span class="line">第五次交换  num = 8x=712,11,10,15,8,2,11,9 </span><br><span class="line">第六次交换  num = 2x=112,19,10,15,8,2,11,9 </span><br><span class="line">第七次交换  num = 11x=212,19,18,15,8,2,11,9</span><br><span class="line">第八次交换  num = 10 x=1 12,27,18,15,8,2,11,9</span><br><span class="line">由此可见，8和2没有变化，即它们所在的序列加一就是没有出现的数字</span><br></pre></td></tr></table></figure><hr><h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h1><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 1, y = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 3, y = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p> 我的解法</p><p>使用blob函数分别将x，y转换成二进制，并将它传给数组返回。然后对它们for循环进行比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingDistance = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> X = <span class="title function_">blob</span>(x);</span><br><span class="line">    <span class="keyword">let</span> Y = <span class="title function_">blob</span>(y);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,j = <span class="number">0</span>;<span class="comment">//j计算x和y二进制位数不同的个数</span></span><br><span class="line">    <span class="keyword">let</span> length = X.<span class="property">length</span> &gt;= Y.<span class="property">length</span> ? X.<span class="property">length</span> : Y.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(X[i]!=Y[i])</span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">blob</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">32</span>);</span><br><span class="line">    arr.<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        i = x % <span class="number">2</span>;</span><br><span class="line">        arr[j++] = i;</span><br><span class="line">        x = <span class="built_in">parseInt</span>(x/<span class="number">2</span>);<span class="comment">//js的Number不分整型和浮点型，所以要使用parseInt将/2的结果转为整型。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方</p><ul><li><strong>移位实现位计数</strong></li></ul><p>​将x和y进行异或，<strong>相同为0，不同为1</strong>，这样异或的结果s中为1的便是x和y二进制中不同的地方。然后让最低位和1进行与运算，相同则加一，不同加0，随后让s右移一位，再进行与运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingDistance = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> s = x ^ y;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        i = s &amp; <span class="number">1</span>;</span><br><span class="line">        count+=i;</span><br><span class="line">        s = s&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Brian Kernighan （比特计算）算法</strong></li></ul><p>​s &#x3D; x ^ y。x和y异或后，所得的s为一个<strong>包含1和0的二进制数</strong>，如10001101，这样需要循环8次才能获得结果，可以使用<strong>Brian Kernighan （比特计算）算法</strong>计算s中1的个数，即使用<strong>x&amp;(x-1)<strong>，每运行一次，s中的1就会减少1个。该算法会</strong>删去s中最右侧的1</strong>，最终循环的次数即为s二进制表示中1的数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingDistance = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">s = x ^ y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;s &gt; <span class="number">0</span>;i++)&#123;</span><br><span class="line">        s = s &amp; (s-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h1><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>题解：使用栈进行解决，将右括号存储在数组中，然后将字符串一一入栈，如果是左括号则入栈，如果是右括号进行判断，如果跟出栈的符号能对应，则继续循环，否则return false。到最后，如果栈为空，则return true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];<span class="comment">//栈</span></span><br><span class="line">    s = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//将字符串分割成数组</span></span><br><span class="line">    <span class="keyword">let</span> right = [<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;]&#x27;</span>];<span class="comment">//将右阔靠存在right数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!right.<span class="title function_">includes</span>(s[i]))&#123;<span class="comment">//如果不是右括号则推入栈中</span></span><br><span class="line">            stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是则进行判断</span></span><br><span class="line">            <span class="keyword">switch</span>(s[i])&#123;<span class="comment">//跟栈顶出栈的元素进行比较，如果能匹配上，则继续循环，不能就return false</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&#125;&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.<span class="property">length</span>==<span class="number">0</span>)&#123;<span class="comment">//最后判断栈的长度，为0则说明全是有效括号，return true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//否则，return false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>我的解法：暴力解法，<strong>利用set去重</strong>获取nums中的唯一值赋给新数组newNums。然后在<strong>深拷贝</strong>一个新的数组newNum。循环nums，如果nums中的值等于newNum中的值，则newNums加上自己。循环完后再循环newNums，如果它减去newNum中的对应的值再除去newNum对应的值大于n&#x2F;2的话则返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> time = nums.<span class="property">length</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> newNums = [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums)];<span class="comment">//去重，获得新数组</span></span><br><span class="line">    <span class="keyword">let</span> newNum = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newNums));<span class="comment">//深拷贝一个新数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; newNums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==newNum[j])<span class="comment">//如果值相等</span></span><br><span class="line">                newNums[j]+=newNum[j];<span class="comment">//newNums加上自身</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; newNums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((newNums[i]-newNum[i])/newNum[i]&gt;time)&#123;<span class="comment">//如果减去自身除以自身大于time则返回</span></span><br><span class="line">            <span class="keyword">return</span> newNum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>用哈希表统计数组元素中每个元素出现的次数，返回所有统计次数超过n&#x2F;2的元素。元素作为哈希表的键，出现的次数作为哈希表的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();<span class="comment">//创建哈希表</span></span><br><span class="line">    <span class="keyword">let</span> time = nums.<span class="property">length</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(nums[i]))&#123;<span class="comment">//如果map有nums[i],则让次数加一</span></span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],map.<span class="title function_">get</span>(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有，则添加</span></span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>())&#123;<span class="comment">//使用for ... of遍历map的key</span></span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(key)&gt;time)&#123;<span class="comment">//如果key对应的值大于time则返回</span></span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h2><p>记录第一个士兵为winner&#x3D;nums[i]，然后设置count计数器为0。遍历循环数组，当与winner相同时，count++，不相同，count–，当count为0时，nums[i]重新赋值给winner。这样遍历结束后，winner就是所求的数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> winner = nums[<span class="number">0</span>];<span class="comment">//创建士兵</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;<span class="comment">//创建计数器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(winner == nums[i])&#123;<span class="comment">//当nums[i]与士兵相同时count++</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;<span class="comment">//减到后面count为0时，winner重新赋值</span></span><br><span class="line">            winner = nums[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//不同时,count--</span></span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> winner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>“同归于尽消杀法” ：</p><p>由于多数超过50%, 比如100个数，那么多数至少51个，剩下少数是49个。</p><ol><li>遍历数组</li><li>第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地，此时领主 winner 就是这个阵营的人，现存兵力 count &#x3D; 1。</li><li>如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地，领主不变，winner 依然是当前这个士兵所属阵营，现存兵力 count 加一；</li><li>如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽。 此时前方阵营兵力-1, 即使双方都死光，这块高地的旗帜 winner 不变，没有可以去换上自己的新旗帜。</li><li>当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主，winner 变成这个士兵所属阵营的旗帜，现存兵力 count ++。</li><li>就这样各路军阀一直厮杀以一敌一同归于尽的方式下去，直到少数阵营都死光，剩下几个必然属于多数阵营的，winner 是多数阵营。</li></ol><p>（多数阵营 51个，少数阵营只有49个，死剩下的2个就是多数阵营的人）</p><h1 id="229-多数元素"><a href="#229-多数元素" class="headerlink" title="229.多数元素||"></a>229.多数元素||</h1><h2 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> time = nums.<span class="property">length</span> / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Element</span> = [];</span><br><span class="line">    <span class="keyword">let</span> newNums = [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums)];</span><br><span class="line">    <span class="keyword">let</span> newNum = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newNums));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; newNums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==newNum[j] &amp;&amp; nums[i]!=<span class="number">0</span>)</span><br><span class="line">                newNums[j]+=newNum[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==newNum[j] &amp;&amp; nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                newNums[j]+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; newNums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newNum[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                formula = (newNums[i]-newNum[i])/<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                formula = (newNums[i]-newNum[i])/newNum[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(formula&gt;time)&#123;</span><br><span class="line">                <span class="title class_">Element</span>.<span class="title function_">push</span>(newNum[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Element</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h2><p>用哈希表统计数组元素中每个元素出现的次数，返回所有统计次数超过n&#x2F;3的元素。元素作为哈希表的键，出现的次数作为哈希表的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> time = nums.<span class="property">length</span> / <span class="number">3</span>;<span class="comment">//获取出现次数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Element</span> = [];</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();<span class="comment">//创建map字典，map键值一一对应</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(nums[i]))&#123;<span class="comment">//如果map有nums[i],则让次数加一</span></span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],map.<span class="title function_">get</span>(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有，则添加</span></span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> o <span class="keyword">of</span> map.<span class="title function_">keys</span>())&#123;<span class="comment">//使用for ... of遍历map的key</span></span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(o)&gt;time)&#123;<span class="comment">//如果key对应的值大于time则将其加入数组</span></span><br><span class="line">            <span class="title class_">Element</span>.<span class="title function_">push</span>(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Element</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,2,1,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>题目要求只是用常量额外空间，所以不能使用哈希表，使用哈希表则空间复杂度为O(n)，可以使用异或运算。</p><p>​异或运算两数相同为0，不同为1。拓展开来，两个不同的数相异或，得到另一个数，当第二次遇到其中一个数时则会还原成另一个数。这用到了异或的交换律和结合律。<em>a</em>⊕<em>b</em>⊕<em>a</em>&#x3D;<em>b</em>⊕<em>a</em>⊕<em>a</em>&#x3D;<em>b</em>⊕(<em>a</em>⊕<em>a</em>)&#x3D;<em>b</em>⊕0&#x3D;<em>b</em>。</p><p><img src="https://assets.leetcode-cn.com/solution-static/136/3.PNG" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> single = nums[<span class="number">0</span>];<span class="comment">//先获取第一个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;<span class="comment">//i从1开始遍历</span></span><br><span class="line">        single ^= nums[i];<span class="comment">//不断与所有数进行异或，相同为0不同为1，剩到最后的数为只出现一次的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希表（不考虑空间复杂度）"><a href="#哈希表（不考虑空间复杂度）" class="headerlink" title="哈希表（不考虑空间复杂度）"></a>哈希表（不考虑空间复杂度）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(nums[i]))&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],map.<span class="title function_">get</span>(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(key) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须<strong>在不复制数组</strong>的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>创建一个count变量为0作为数组下标，for …of遍历数组，当数组的值不为0的时候，将当前数组的值赋给以count作为下标的数组，令count++进入下一次循环。随后count的值一定为数组不为0的数字的长度。for循环nums.length-count次，给数组末尾补0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;<span class="comment">//for...of中的i是数组的value值</span></span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;<span class="comment">//此方法是索引从0开始，让数组的不为0的值覆盖为0的值</span></span><br><span class="line">            nums[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;count&lt;nums.<span class="property">length</span>;count++)&#123;</span><br><span class="line">        nums[count] = <span class="number">0</span>;<span class="comment">//想数组末尾补0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>两层循环遍历，当遍历的值为0时，让当前值与后面的值进行交换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">            nums[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;count&lt;nums.<span class="property">length</span>;count++)&#123;</span><br><span class="line">        nums[count] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h1><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="title class_">Math</span>.<span class="title function_">floor</span>((n + <span class="number">1</span>) / <span class="number">2</span>); ++j) &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>假设链表为 1→2→3→∅1，我们想要把它改成 ∅←1←2←3.</p><p>在遍历链表时，将当前节点的 next\textit{next}next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">        <span class="keyword">const</span> next = curr.<span class="property">next</span>;</span><br><span class="line">        curr.<span class="property">next</span> = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h2 id="数组双指针"><a href="#数组双指针" class="headerlink" title="数组双指针"></a>数组双指针</h2><p>将链表的值从头节点开始一一存进数组，然后用双指针从头和末尾去遍历数组进行比对。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [];</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(head.<span class="property">val</span>);</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,j = arr.<span class="property">length</span>-<span class="number">1</span>;i&lt;arr.<span class="property">length</span>,j&gt;<span class="number">0</span>;i++,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != arr[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>将head用全局变量指针存储，然后创建递归函数，<strong>递归会为每一次递归的值创建一个执行上下文栈保留当前状态</strong>，当递归到链表的最后会从后往前回退，然后利用这个特性跟全局变量指针进行对比，每一次都让指针指向下一个节点。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> frontPointer ;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recursivelyCheck</span> (<span class="attr">current</span>:<span class="title class_">ListNode</span> | <span class="literal">null</span>):<span class="built_in">boolean</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current)&#123;<span class="comment">//判断当前节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_">recursivelyCheck</span>(current.<span class="property">next</span>)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//递归会一直执行下去，并将变量当前状态存储在执行上下文栈中，直到链表的末尾后函数返回true,!true不执行所以执行下面的语句。</span></span><br><span class="line">        <span class="keyword">if</span>(frontPointer.<span class="property">val</span> != current.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//将全局指针保存的值跟栈返回的状态的值进行对比，如果不同，则会返回false，上一条if语句就会执行，一直返回fals直到执行上下文栈为空</span></span><br><span class="line">        frontPointer = frontPointer.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    frontPointer = head;<span class="comment">//将头节点用全局变量存储</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">recursivelyCheck</span>(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><ol><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否回文。</li><li>恢复链表。</li><li>返回结果。</li></ol><p>使用<strong>快慢指针</strong>在一次遍历中找到：<strong>慢指针一次走一步，快指针一次走两步</strong>，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="title function_">reverseList</span> = (<span class="params">head</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextTemp = curr.<span class="property">next</span>;</span><br><span class="line">        curr.<span class="property">next</span> = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">endOfFirstHalf</span>  (<span class="attr">head</span>:<span class="title class_">ListNode</span> | <span class="literal">null</span>):<span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast.<span class="property">next</span> != <span class="literal">null</span> &amp;&amp; fast.<span class="property">next</span>.<span class="property">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = head;</span><br><span class="line">    <span class="keyword">let</span> afterHalf = <span class="title function_">endOfFirstHalf</span>(head);</span><br><span class="line">    <span class="keyword">let</span> reverAfter = <span class="title function_">reverseList</span>(afterHalf);</span><br><span class="line">    <span class="keyword">while</span>(reverAfter!=<span class="literal">null</span> &amp;&amp; left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.<span class="property">val</span> !== reverAfter.<span class="property">val</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left = left.<span class="property">next</span>;</span><br><span class="line">        reverAfter = reverAfter.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h2 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h2><p>首先，我们设定一个哨兵节点 <code>prehead</code> ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 <code>prev </code>指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：<strong>如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作</strong>。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p><p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTwoLists</span>(<span class="params">list1: ListNode | <span class="literal">null</span>, list2: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Link</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="title class_">Link</span>;</span><br><span class="line">    <span class="keyword">while</span>(list1!== <span class="literal">null</span> &amp;&amp; list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.<span class="property">val</span> &lt;= list2.<span class="property">val</span>)&#123;</span><br><span class="line">            prev.<span class="property">next</span> = list1;</span><br><span class="line">            list1 = list1.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev.<span class="property">next</span> = list2;</span><br><span class="line">            list2 = list2.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev.<span class="property">next</span> = list1 === <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Link</span>.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>遍历链表，将链表的每一个节点存入哈希表，最开始判断哈希表中是否有该节点，有的话说明是循环链表，直接返回true。如果循环完哈希表中的值都为1，说明不是循环链表，返回false。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(head))&#123;<span class="comment">//先判断哈希表中是否含有该节点，有的话说明是循环链表返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(head,<span class="number">1</span>);<span class="comment">//没有该节点往哈希表中添加该节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//循环结束，直到最后都没有返回true说明不是循环链表，返回false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>「Floyd 判圈算法」（又称龟兔赛跑算法），假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。<strong>慢指针每次只移动一步，而快指针每次移动两步</strong>。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>将fast设置为head.next，将slow设置为head是为了能进入while循环，因为循环条件是<strong>slow!&#x3D;fast</strong>，如果他们相等，则无法进入循环。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> fast = head.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast === <span class="literal">null</span> || fast.<span class="property">next</span> === <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><h2 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h2><p>set集合不允许有重复的值，所以可以先将headA的所有节点存入set集合，然后再循环headB判断，如果有相同的说明他们是相交的起始节点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getIntersectionNode</span>(<span class="params">headA: ListNode | <span class="literal">null</span>, headB: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">while</span>(headA != <span class="literal">null</span>)&#123;</span><br><span class="line">        set.<span class="title function_">add</span>(headA);</span><br><span class="line">        headA = headA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headB != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.<span class="title function_">has</span>(headB))&#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>使用双指针的方法，可以将空间复杂度降至 O(1))。</p><p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><p>当链表 headA 和 headB 都不为空时，创建两个指针 pA和 pB，初始时分别指向两个链表的头节点 headA和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><p>每步操作需要同时更新指针 pA 和 pB。</p><p>如果指针 pA 不为空，则将指针 pA移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p><p>如果指针 pA为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p><p>当指针 pA和 pB指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getIntersectionNode</span>(<span class="params">headA: ListNode | <span class="literal">null</span>, headB: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(headA === <span class="literal">null</span> || headB === <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable constant_">PA</span> = headA,<span class="variable constant_">PB</span> = headB;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable constant_">PA</span> != <span class="variable constant_">PB</span>)&#123;</span><br><span class="line">        <span class="variable constant_">PA</span> = <span class="variable constant_">PA</span> ===<span class="literal">null</span> ? headB : <span class="variable constant_">PA</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="variable constant_">PB</span> = <span class="variable constant_">PB</span> ===<span class="literal">null</span> ? headA : <span class="variable constant_">PB</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">PA</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>子树堆成条件：</p><ol><li><strong>它们两个根节点具有相同的值</strong> </li><li><strong>每个树的右子树都与另一个树的左子树镜像对称</strong></li></ol><h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>通过递归判断，第一次将树的根传两次进去，然后第二次传根的left和right进行判断，第三次传根left的left和根right的right以及根left的right和根right的left进行比较….以此类推，直到到树的底层为止</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span></span><br><span class="line">    <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = (left===<span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = (right===<span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归判断二叉树是否对称</span></span><br><span class="line"><span class="keyword">const</span> check = (<span class="attr">p</span>:<span class="title class_">TreeNode</span>|<span class="literal">null</span>,<span class="attr">q</span>:<span class="title class_">TreeNode</span>|<span class="literal">null</span>):<span class="function"><span class="params">boolean</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断两个节点是否同时不存在，不存在返回true</span></span><br><span class="line">    <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果只有一个不存在，说明不对称，返回false</span></span><br><span class="line">    <span class="keyword">return</span> p.<span class="property">val</span> === q.<span class="property">val</span> &amp;&amp; <span class="title function_">check</span>(p.<span class="property">left</span>,q.<span class="property">right</span>) &amp;&amp; <span class="title function_">check</span>(p.<span class="property">right</span>,q.<span class="property">left</span>); <span class="comment">//第一个条件是两个节点的值是否相等，第二个条件是将左节点的左儿子和右节点的右儿子进行比较，第三个条件是将左节点的右儿子和右节点的左儿子进行比较</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSymmetric</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">check</span>(root,root);<span class="comment">//首次传两个根节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h2><p>使用队列，创建一个队列，先推入两次根节点，随后进行循环（循环条件是队列的长度），两次取出队列的值进行判断，如果两个节点都为空说明这两个节点是对称的，设置为continue，如果两个节点有一个为空或者它们的val值不相等，则返回false。然后分别推入节点的左儿子和另一个节点的右儿子，以及节点的右儿子和另一个节点的左儿子，再次进入循环。循环结束，返回true。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> check = (<span class="attr">u</span>:<span class="title class_">TreeNode</span>|<span class="literal">null</span> , <span class="attr">v</span>:<span class="title class_">TreeNode</span>|<span class="literal">null</span>):<span class="function"><span class="params">boolean</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">q</span>:<span class="title class_">TreeNode</span>[] = [];<span class="comment">//创建队列</span></span><br><span class="line">    q.<span class="title function_">push</span>(u);<span class="comment">//推入根节点两次，因为要分别判断根的left和right</span></span><br><span class="line">    q.<span class="title function_">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="property">length</span>)&#123;<span class="comment">//进行循环</span></span><br><span class="line">        u = q.<span class="title function_">shift</span>();<span class="comment">//取出队列的前两个值进行判断</span></span><br><span class="line">        v = q.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!u &amp;&amp; !v) <span class="keyword">continue</span>;<span class="comment">//如果它们都为空说明是对称的，结束本次循环进入下次循环</span></span><br><span class="line">        <span class="keyword">if</span>((!u || !v) || u.<span class="property">val</span> != v.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果它们有一个为空，或者值不相等，返回false</span></span><br><span class="line"><span class="comment">//推入u的left和v的right，u的right和v的left，因为它们镜像，要比对的是它们的值</span></span><br><span class="line">        q.<span class="title function_">push</span>(u.<span class="property">left</span>);</span><br><span class="line">        q.<span class="title function_">push</span>(v.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">        q.<span class="title function_">push</span>(u.<span class="property">right</span>);</span><br><span class="line">        q.<span class="title function_">push</span>(v.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//循环结束，说明是对称的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSymmetric</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">check</span>(root,root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1], root2 = [1,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure><h2 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h2><ol><li>root1为null，root2不为null，返回root2</li><li>root2为null，root1不为null，返回root1</li><li>创建新的树，将root1和root2的val值进行相加，节点的left和right为root1和root2节点的left和right的val值相加（即进入递归）</li><li>最后返回树</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTrees</span>(<span class="params">root1: TreeNode | <span class="literal">null</span>, root2: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;</span><br><span class="line">    <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.<span class="property">val</span>+root2.<span class="property">val</span>);</span><br><span class="line">    t.<span class="property">left</span> = <span class="title function_">mergeTrees</span>(root1.<span class="property">left</span>,root2.<span class="property">left</span>);</span><br><span class="line">    t.<span class="property">right</span> = <span class="title function_">mergeTrees</span>(root1.<span class="property">right</span>,root2.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-3"><a href="#迭代-3" class="headerlink" title="迭代"></a>迭代</h2><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h2><p>如果我们知道了左子树和右子树的最大深度 lll 和 rrr，那么该二叉树的最大深度即为</p><p>max⁡(l,r)+1 \max(l,r) + 1<br>max(l,r)+1<br>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1)O(1)O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/solutions/349250/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/">104. 二叉树的最大深度 - 力扣（Leetcode）</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxDepth</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">maxDepth</span>(root.<span class="property">left</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">maxDepth</span>(root.<span class="property">right</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> max = left&gt;right?<span class="attr">left</span>:right;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226.反转二叉树"></a>226.反转二叉树</h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h2><p>采用先序遍历，先判断当前二叉树是否是null，是的话就返回null，遍历交换当前节点的左右节点，然后再递归，将左右节点分别传入函数，最后返回root二叉树。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> left  = root.<span class="property">left</span>;<span class="comment">//用变量获取左右节点</span></span><br><span class="line">    <span class="keyword">let</span> right = root.<span class="property">right</span>;</span><br><span class="line">    root.<span class="property">left</span> = right;<span class="comment">//交换左右节点</span></span><br><span class="line">    root.<span class="property">right</span> = left;</span><br><span class="line">    <span class="title function_">invertTree</span>(root.<span class="property">left</span>);<span class="comment">//将左右节点传入函数进行递归交换</span></span><br><span class="line">    <span class="title function_">invertTree</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-4"><a href="#迭代-4" class="headerlink" title="迭代"></a>迭代</h2><p>采用栈存储当前节点，循环条件是栈的长度不为0。然后定义变量存储出栈的值，判断变量是否为null，是的话跳过本次循环，不是则交换左右节点。将左右节点再推入栈中,直到栈为空。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    stack.<span class="title function_">push</span>(root);<span class="comment">//将根节点存储栈中</span></span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> t = stack.<span class="title function_">pop</span>();<span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果t为空，则跳过本次循环，不交换</span></span><br><span class="line">        <span class="keyword">let</span> left = t.<span class="property">left</span>;<span class="comment">//分别用变量存储左右节点</span></span><br><span class="line">        <span class="keyword">let</span> right = t.<span class="property">right</span>;</span><br><span class="line">        t.<span class="property">left</span> = right;<span class="comment">//将t的左右节点进行交换</span></span><br><span class="line">        t.<span class="property">right</span> = left;</span><br><span class="line">        stack.<span class="title function_">push</span>(t.<span class="property">left</span>);<span class="comment">//将交换后的左右节点再推入栈中，进入循环</span></span><br><span class="line">        stack.<span class="title function_">push</span>(t.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h1><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h2 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h2><p>中序遍历，左子树——根节点——右子树，访问左子树和右子树的时候同样可以以这种方式遍历。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">t</span>:<span class="built_in">number</span>[] = [];</span><br><span class="line">    <span class="comment">//递归遍历函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root:TreeNode</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="comment">//递归结束条件,节点为空，返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">inorder</span>(root.<span class="property">left</span>);<span class="comment">//先遍历左节点,所有的状态暂存栈中</span></span><br><span class="line">        t.<span class="title function_">push</span>(root.<span class="property">val</span>);<span class="comment">//左节点为空后,一一将值推入数组</span></span><br><span class="line">        <span class="title function_">inorder</span>(root.<span class="property">right</span>);<span class="comment">//遍历右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-5"><a href="#迭代-5" class="headerlink" title="迭代"></a>迭代</h2><p>先一次性将树的左子树的左节点全都推入栈中，随后取出栈顶元素，将其推入数组，然后将当前节点赋值为节点的右孩子，如果右孩子为空，但栈长度仍大于0，进入循环。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">t1</span>:<span class="title class_">TreeNode</span>[] = [],<span class="attr">t2</span>:<span class="built_in">number</span>[] = [];</span><br><span class="line">    <span class="keyword">while</span>(t1.<span class="property">length</span> &gt; <span class="number">0</span> || root)&#123;<span class="comment">//循环条件：数组的长度大于0或者root不为null</span></span><br><span class="line">        <span class="keyword">while</span>(root)&#123;<span class="comment">//先把树的左子树的左节点全都推入栈</span></span><br><span class="line">            t1.<span class="title function_">push</span>(root);</span><br><span class="line">            root = root.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = t1.<span class="title function_">pop</span>();<span class="comment">//栈顶元素出栈</span></span><br><span class="line">        t2.<span class="title function_">push</span>(root.<span class="property">val</span>);<span class="comment">//将值推入数组</span></span><br><span class="line">        root = root.<span class="property">right</span>;<span class="comment">//root赋值为它的右孩子，若右孩子不为空，则会在下一次循环推入栈中，为空，则会跳过root循环，下一个栈顶元素出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h2><p>设置递归函数，传递三个参数，判断的节点，节点的下界，节点的上界，然后依次递归，如果只单纯比较把节点的左节点和右节点和节点进行比较，那么会出现左右子树中存在值比当前节点小或大的情况，所以<strong>比较的同时要把当前节点的上下界一起传递</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isValidBST</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isTrue = (<span class="attr">root</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>,up,lower):<span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &gt;= up || root.<span class="property">val</span> &lt;= lower)   <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果当前节点大于等于上届，或者小于等于下界，说明不在范围区间内，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">isTrue</span>(root.<span class="property">left</span>,root.<span class="property">val</span>,lower) &amp;&amp; <span class="title function_">isTrue</span>(root.<span class="property">right</span>,up,root.<span class="property">val</span>);<span class="comment">//左节点要比当前节点要小，所以上界传当前节点值，下界为Infinity，右节点要比当前节点大，所以下界传当前节点的值，上界为Infinity</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isTrue</span>(root,<span class="title class_">Infinity</span>,-<span class="title class_">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-6"><a href="#迭代-6" class="headerlink" title="迭代"></a>迭代</h2><p>将节点的所有左节点推入栈，然后出栈顶元素，将栈顶元素的值和定义的最小值比较，如果小的话说明不是二叉搜索树，返回false，大则将节点的值赋给最小值，节点的右节点赋给root。在循环结束后，说明遍历完，返回true。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isValidBST</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> inorder = -<span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span> &gt; <span class="number">0</span> || root)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(root);</span><br><span class="line">            root = root.<span class="property">left</span>;<span class="comment">//将节点的所有左节点入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="title function_">pop</span>();<span class="comment">//出栈顶元素，即最左边的元素</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &lt;= inorder) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果节点的值比定义的最小值小，说明不符合条件按</span></span><br><span class="line">        inorder = root.<span class="property">val</span>;<span class="comment">//大的话进行赋值，进入下次循环</span></span><br><span class="line">        root = root.<span class="property">right</span>;<span class="comment">//节点赋值为右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
