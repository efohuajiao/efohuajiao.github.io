<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TIndex终端笔记</title>
      <link href="/2023/06/30/TIndex%E7%BB%88%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/30/TIndex%E7%BB%88%E7%AB%AF%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><ul><li><p><code>npm create vite TIndex</code>创建vite项目</p></li><li><p>进入TIndex目录，<code>npm install </code>下载配置文件</p></li></ul><h2 id="配置处理"><a href="#配置处理" class="headerlink" title="配置处理"></a>配置处理</h2><h3 id="找不到模块vue"><a href="#找不到模块vue" class="headerlink" title="找不到模块vue"></a>找不到模块vue</h3><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230620151159924.png" alt="image-20230620151159924"></p><p>在ts的配置文件<code>tsconfig.json</code>中将<code>moduleResolution: &quot;bundler&quot;</code>修改为<code>moduleResolution: &quot;node&quot;</code>。</p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230620153331040.png" alt="image-20230620153331040"></p><p>原因：当使用此选项时，TypeScript 将按照 Node.js 的模块解析规则来解析模块。它会根据 <code>node_modules</code> 文件夹和 <code>package.json</code> 文件中的 <code>module</code> 字段来找到模块。</p><h3 id="找不到vue文件"><a href="#找不到vue文件" class="headerlink" title="找不到vue文件"></a>找不到vue文件</h3><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230620152547953.png" alt="image-20230620152547953"></p><p>解决办法：在自动生成的vite-env.d.ts配置文件中添加如下配置。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.vue&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">DefineComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">component</span>: <span class="title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, <span class="built_in">any</span>&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> component</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​原因：TS无法解析vue文件，需要添加配置进行解析</p><h3 id="tsconfig-json错误"><a href="#tsconfig-json错误" class="headerlink" title="tsconfig.json错误"></a>tsconfig.json错误</h3><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230620153155337.png" alt="image-20230620153155337"></p><p>最新的TS已经废弃了<code>allowImportingTsExtensions</code>配置项，需改为<code>allowSyntheticDefaultImports: true</code>。</p><h1 id="代码校验、美观配置"><a href="#代码校验、美观配置" class="headerlink" title="代码校验、美观配置"></a>代码校验、美观配置</h1><h2 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h2><ol><li>安装eslint <code> npm i eslint -D</code>   (安装在开发环境)</li><li>生成配置文件 <code>npx eslint --init</code>（后面会有提示，比如<strong>仅检验代码规范还是代码问题等</strong>按照提示操作即可，最后会生成**.eslintrc.cjs文件**）</li><li>vue3环境代码校验插件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查</span><br><span class="line">&quot;eslint-config-prettier&quot;: &quot;^8.6.0&quot;,</span><br><span class="line">&quot;eslint-plugin-import&quot;: &quot;^2.27.5&quot;,</span><br><span class="line">&quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,</span><br><span class="line"># 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低</span><br><span class="line">&quot;eslint-plugin-prettier&quot;: &quot;^4.2.1&quot;,</span><br><span class="line"># vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南</span><br><span class="line">&quot;eslint-plugin-vue&quot;: &quot;^9.9.0&quot;,</span><br><span class="line"># 该解析器允许使用Eslint校验所有babel code</span><br><span class="line">&quot;@babel/eslint-parser&quot;: &quot;^7.19.1&quot;,</span><br></pre></td></tr></table></figure><p>安装指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser</span><br></pre></td></tr></table></figure><ol start="4"><li>在**.eslintrc.cjs**文件中加入如下配置(出自尚硅谷——硅谷甄选项目)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @see https://eslint.bootcss.com/docs/rules/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">jest</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 指定如何解析语法 */</span></span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&#x27;vue-eslint-parser&#x27;</span>,</span><br><span class="line">  <span class="comment">/** 优先级低于 parse 的语法解析配置 */</span></span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="string">&#x27;latest&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>,</span><br><span class="line">    <span class="attr">jsxPragma</span>: <span class="string">&#x27;React&#x27;</span>,</span><br><span class="line">    <span class="attr">ecmaFeatures</span>: &#123;</span><br><span class="line">      <span class="attr">jsx</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 继承已有的规则 */</span></span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:vue/vue3-essential&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;@typescript-eslint&#x27;</span>],</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * &quot;off&quot; 或 0    ==&gt;  关闭规则</span></span><br><span class="line"><span class="comment">   * &quot;warn&quot; 或 1   ==&gt;  打开的规则作为警告（不影响代码执行）</span></span><br><span class="line"><span class="comment">   * &quot;error&quot; 或 2  ==&gt;  规则作为一个错误（代码不能执行，界面报错）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// eslint（https://eslint.bootcss.com/docs/rules/）</span></span><br><span class="line">    <span class="string">&#x27;no-var&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 要求使用 let 或 const 而不是 var</span></span><br><span class="line">    <span class="string">&#x27;no-multiple-empty-lines&#x27;</span>: [<span class="string">&#x27;warn&#x27;</span>, &#123; <span class="attr">max</span>: <span class="number">1</span> &#125;], <span class="comment">// 不允许多个空行</span></span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-unexpected-multiline&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 禁止空余的多行</span></span><br><span class="line">    <span class="string">&#x27;no-useless-escape&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 禁止不必要的转义字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// typeScript (https://typescript-eslint.io/rules)</span></span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-unused-vars&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 禁止定义未使用的变量</span></span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/prefer-ts-expect-error&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 禁止使用 @ts-ignore</span></span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-explicit-any&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 禁止使用 any 类型</span></span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-non-null-assertion&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-namespace&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 禁止使用自定义 TypeScript 模块和命名空间。</span></span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/semi&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eslint-plugin-vue (https://eslint.vuejs.org/rules/)</span></span><br><span class="line">    <span class="string">&#x27;vue/multi-word-component-names&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 要求组件名称始终为 “-” 链接的单词</span></span><br><span class="line">    <span class="string">&#x27;vue/script-setup-uses-vars&#x27;</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 防止&lt;script setup&gt;使用的变量&lt;template&gt;被标记为未使用</span></span><br><span class="line">    <span class="string">&#x27;vue/no-mutating-props&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 不允许组件 prop的改变</span></span><br><span class="line">    <span class="string">&#x27;vue/attribute-hyphenation&#x27;</span>: <span class="string">&#x27;off&#x27;</span>, <span class="comment">// 对模板中的自定义组件强制执行属性命名样式</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以使用以下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;plugin:vue/vue3-recommended&quot;</span>, <span class="string">&quot;plugin:prettier/recommended&quot;</span>],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&quot;@typescript-eslint/parser&quot;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&quot;vue&quot;</span>, <span class="string">&quot;@typescript-eslint&quot;</span>, <span class="string">&quot;prettier&quot;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&quot;prettier/prettier&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>生成忽略文件</li></ol><p>文件名<code>.eslintignore</code>，<strong>忽略dist和node_modules文件夹</strong></p><h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><p>有了eslint，为什么还要有prettier？eslint针对的是javascript，他是一个检测工具，包含js语法以及少部分格式问题，在eslint看来，语法对了就能保证代码正常运行，格式问题属于其次；</p><p>而prettier属于格式化工具，它看不惯格式不统一，所以它就把eslint没干好的事接着干，另外，prettier支持包含js在内的多种语言。</p><p><strong>安裝依赖包</strong></p><p>​<code>npm install -D eslint-plugin-prettier prettier eslint-config-prettier</code></p><h1 id="引入Ant-Design组件库"><a href="#引入Ant-Design组件库" class="headerlink" title="引入Ant Design组件库"></a>引入Ant Design组件库</h1><h2 id="vite按需加载"><a href="#vite按需加载" class="headerlink" title="vite按需加载"></a>vite按需加载</h2><p>antd官网vite按需加载推荐在 vite.config.js 文件中引用 ‘’vite-plugin-components‘’，该方法是错误的，官网将<code>vite-plugin-components </code>已经更名<code> unplugin-vue-components</code></p><ul><li>安装unplugin-vue-components</li></ul><p>​<code>npm i unplugin-vue-components -D </code></p><ul><li>在vite.config.ts中引用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AntDesignVueResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">AntDesignVueResolver</span>()]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>随后即可在项目中直接使用所需的组件，不需要引用，再用app.use进行注册。</p><h1 id="设置路径别名"><a href="#设置路径别名" class="headerlink" title="设置路径别名"></a>设置路径别名</h1><p>如果使用**@<strong>代替</strong>src**，而不使用相对路径，如下图所示。</p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230708101030651.png" alt="image-20230708101030651"></p><p>则需要配置两个配置文件<strong>vite.config.ts</strong>和<strong>tsconfig.json</strong></p><ul><li>vite.config.ts</li></ul><ol><li>引入path模块</li></ol><p><code>import path from &#39;path&#39;</code></p><ol start="2"><li>在defineConfig中进行如下配置</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">          <span class="string">&quot;@&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./src&quot;</span>), <span class="comment">//为src配置别名</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>tsconfig.json</li></ul><p>​在<strong>compilerOptions</strong>中添加如下配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@/*&quot;</span>:[<span class="string">&quot;src/*&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Pinia状态管理"><a href="#Pinia状态管理" class="headerlink" title="Pinia状态管理"></a>Pinia状态管理</h1><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>npm安装</li></ol><p>​<code>npm i pinia</code>或<code>yarn add pinia</code></p><ol start="2"><li>在main.ts中创建pinia实例进行使用</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>通过<code>defineStore</code>API创建store（一般新建一个store文件夹专门存放状态文件）</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTerminalConfigStore = <span class="title function_">defineStore</span>(<span class="string">&quot;terminalConfig&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 状态</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">      <span class="comment">// 计算属性</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">// 方法，用于进行异步操作和操作状态</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="命令组成"><a href="#命令组成" class="headerlink" title="命令组成"></a>命令组成</h1><p>TIndex是借鉴Linux的命令格式的，所以命令由三部分组成，分别是<strong>命令本身</strong>、<strong>命令参数</strong>、<strong>命令选项</strong>。命令本身是必须的，命令参数和命令选项是可选的。</p><p>命令选项的作用是说明<strong>对命令的要求</strong></p><p>命令参数是描述<strong>命令的作用对象</strong><img src="https://s2.loli.net/2023/01/19/vBmRksyIF7jCdZ4.png" alt="img"></p><p>接下来看看TIndex的命令组成，以baidu命令为例（只看与Linux对应的部分）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">baiduCommand</span>: <span class="title class_">CommandType</span> = &#123;</span><br><span class="line">  <span class="attr">func</span>: <span class="string">&quot;baidu&quot;</span>, <span class="comment">// 对应command</span></span><br><span class="line">  <span class="attr">params</span>: [ <span class="comment">// 对应arguments</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">desc</span>: <span class="string">&quot;搜索内容&quot;</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">options</span>: [ <span class="comment">// 对应options</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&quot;self&quot;</span>,</span><br><span class="line">      <span class="attr">desc</span>: <span class="string">&quot;是否在当前页打开&quot;</span>,</span><br><span class="line">      <span class="attr">alias</span>: [<span class="string">&quot;s&quot;</span>],</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;boolean&quot;</span>, <span class="comment">// 用于设置s或者self的类型</span></span><br><span class="line">      <span class="attr">defaultValue</span>: <span class="literal">false</span>, <span class="comment">// 默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&quot;picture&quot;</span>,</span><br><span class="line">      <span class="attr">desc</span>: <span class="string">&quot;是否搜索图片&quot;</span>,</span><br><span class="line">      <span class="attr">alias</span>: [<span class="string">&quot;p&quot;</span>],</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;boolean&quot;</span>, <span class="comment">// 用于设置s或者self的类型</span></span><br><span class="line">      <span class="attr">defaultValue</span>: <span class="literal">false</span>, <span class="comment">// 默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="title function_">action</span>(<span class="params">options, terminal</span>) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="命令执行过程"><a href="#命令执行过程" class="headerlink" title="命令执行过程"></a>命令执行过程</h1><ol><li>终端Terminal 输出命令通过<strong>doSubmitCommand函数</strong>给父组件传递命令，参数为<strong>命令字符串</strong></li><li>通过父组件<strong>IndexPage</strong>调用<strong>props.onSubmitCommand</strong>提交命令，参数为<strong>命令字符串</strong></li><li>组件IndexPage中通过<strong>doCommandExecute</strong>（函数位于core文件夹中）进行命令解析（解析文本，解析参数），参数为<strong>命令字符串，终端组件本身(通过ref获取组件）</strong></li><li>每个命令（core文件夹下）最终都会有一个action函数进行执行命令，最后执行调用action即可</li></ol><h2 id="命令解析后的parsedOptions"><a href="#命令解析后的parsedOptions" class="headerlink" title="命令解析后的parsedOptions"></a>命令解析后的parsedOptions</h2><p>_ 存放 params，剩下options以[key:value]的形式保存。</p><p>getOpts库会将以-或–开头的参数置为当作options，以key:value的形式保存。</p><p>当输入user –help时，help后面没有跟参数，那么getOpts库就会将help当作key，value默认置为true，即<code>help: true</code>（注：当输入 user -help只有一个-时，getOpts会把help拆分成字符数组，即<code>h:true,e:true,l:true,p:true</code>)</p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722110029147.png" alt="image-20230722110029147"></p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722110050416.png" alt="image-20230722110050416"></p><p>而当输入user –help  you 时，help后面跟了参数，则help的value值为you，即<code>help: you</code></p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722110151715.png" alt="image-20230722110151715"></p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722110200186.png" alt="image-20230722110200186"></p><p>当输入user help时，getOpts就会将help当作params，置于_数组中。</p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722110534132.png" alt="image-20230722110534132"></p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722110545151.png" alt="image-20230722110545151"></p><p>依据这些获取的参数就可以进行一系列操作，就以<code>user register -u huajiao1 -p 12345 -e 123@qq.com </code>为例，此时getOpts的解析结果应该是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">_</span>:[<span class="string">&#x27;register&#x27;</span>],</span><br><span class="line"><span class="attr">u</span>:<span class="string">&#x27;huajiao1&#x27;</span>,</span><br><span class="line"><span class="attr">p</span>:<span class="string">&#x27;12345&#x27;</span>,</span><br><span class="line"><span class="attr">e</span>:<span class="string">&#x27;123@qq.com&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722111215469.png" alt="image-20230722111215469"></p><p>此时因为_中有子命令，所以会在<code>doCommandExecute</code>中进行判断，并进行递归执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  _.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">  command.<span class="property">subCommands</span> &amp;&amp;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(command.<span class="property">subCommands</span>).<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 把子命令当做新命令解析，user login xxx =&gt; login xxx</span></span><br><span class="line">  <span class="keyword">const</span> subText = text.<span class="title function_">substring</span>(text.<span class="title function_">indexOf</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">doCommandExecute</span>(subText, terminal, command);</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// return是因为只执行子命令即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以register又会作为新命令再执行一次，即<code>register -u huajiao1 -p 12345 -e 123@qq.com  </code></p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722112757031.png" alt="image-20230722112757031"></p><h1 id="具体命令"><a href="#具体命令" class="headerlink" title="具体命令"></a>具体命令</h1><h2 id="快捷键命令"><a href="#快捷键命令" class="headerlink" title="快捷键命令"></a>快捷键命令</h2><p>监听键盘的onkeydown事件，获取按下的键值。将所需要的快捷键都注册到快捷键列表中，快捷键列表中每一个快捷键的参数类型定义如下。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快捷键类型定义</span></span><br><span class="line">  <span class="keyword">interface</span> shortcut &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">string</span>; <span class="comment">// 按下的键对应的code</span></span><br><span class="line">    desc?: <span class="built_in">string</span>; <span class="comment">// 案件描述</span></span><br><span class="line">    keyDesc?: <span class="built_in">string</span>; <span class="comment">// 功能描述</span></span><br><span class="line">    ctrlKey?: <span class="built_in">boolean</span>; <span class="comment">// 是否按下ctrl键</span></span><br><span class="line">    shiftKey?: <span class="built_in">boolean</span>; <span class="comment">// 是否按下shift键</span></span><br><span class="line">    metaKey?: <span class="built_in">boolean</span>; <span class="comment">// 是否按下meta键</span></span><br><span class="line">    <span class="attr">action</span>: <span class="function">(<span class="params">e: KeyboardEvent, terminal: TerminalType</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中<strong>ctrlKey</strong>、<strong>shiftKey</strong>、<strong>metaKey</strong>参数的作用为用于判定<strong>Ctrl+L</strong>这样的快捷键，判断时需要<strong>跟event的ctrlKey、shiftKey、metaKey键</strong>进行比较，因为KeyboardEvent中可以获取到这些键是否按下的布尔值。</p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230715110831932.png" alt="image-20230715110831932"></p><p>随后只需进行比较即可,快捷键实现的完全代码如下所示。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">shortcutRegister</span> = (<span class="params">terminal: TerminalType</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onkeydown</span> = <span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> key = e.<span class="property">key</span>; <span class="comment">// 获取快捷键</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt;= <span class="string">&quot;a&quot;</span> &amp;&amp; key &lt;= <span class="string">&quot;z&quot;</span> &amp;&amp; !e.<span class="property">metaKey</span> &amp;&amp; !e.<span class="property">shiftKey</span> &amp;&amp; !e.<span class="property">ctrlKey</span>) &#123;</span><br><span class="line">            terminal.<span class="title function_">inputFocus</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> code = e.<span class="property">code</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> shortcut <span class="keyword">of</span> shortcutList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                code === shortcut.<span class="property">code</span> &amp;&amp;</span><br><span class="line">                e.<span class="property">ctrlKey</span> === !!shortcut.<span class="property">ctrlKey</span> &amp;&amp; <span class="comment">// 取两次反是因为快捷键中可能没有定义ctrlKey、shift或metaKey，所以其值为undefined，需要使用!!将其转换为布尔值</span></span><br><span class="line">                e.<span class="property">shiftKey</span> === !!shortcut.<span class="property">shiftKey</span> &amp;&amp;</span><br><span class="line">                e.<span class="property">metaKey</span> === !!shortcut.<span class="property">metaKey</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                shortcut.<span class="title function_">action</span>(e, terminal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快捷键类型定义</span></span><br><span class="line">    <span class="keyword">interface</span> shortcut &#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="built_in">string</span>; <span class="comment">// 按下的键对应的code</span></span><br><span class="line">        desc?: <span class="built_in">string</span>; <span class="comment">// 案件描述</span></span><br><span class="line">        keyDesc?: <span class="built_in">string</span>; <span class="comment">// 功能描述</span></span><br><span class="line">        ctrlKey?: <span class="built_in">boolean</span>; <span class="comment">// 是否按下ctrl键</span></span><br><span class="line">        shiftKey?: <span class="built_in">boolean</span>; <span class="comment">// 是否按下shift键</span></span><br><span class="line">        metaKey?: <span class="built_in">boolean</span>; <span class="comment">// 是否按下meta键</span></span><br><span class="line">        <span class="attr">action</span>: <span class="function">(<span class="params">e: KeyboardEvent, terminal: TerminalType</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快捷键列表，以后想要新增快捷键只需在这里进行添加即可，注意填写正确其对应的参数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">shortcutList</span>: shortcut[] = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">desc</span>: <span class="string">&quot;清屏&quot;</span>,</span><br><span class="line">            <span class="attr">code</span>: <span class="string">&quot;KeyL&quot;</span>,</span><br><span class="line">            <span class="attr">keyDesc</span>: <span class="string">&quot;Ctrl + L&quot;</span>,</span><br><span class="line">            <span class="attr">ctrlKey</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="title function_">action</span>(<span class="params">e, terminal</span>) &#123;</span><br><span class="line">                e.<span class="title function_">preventDefault</span>();</span><br><span class="line">                terminal.<span class="title function_">clear</span>();</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">desc</span>: <span class="string">&quot;回车执行命令后聚焦文本框&quot;</span>,</span><br><span class="line">            <span class="attr">code</span>: <span class="string">&quot;Enter&quot;</span>,</span><br><span class="line">            <span class="title function_">action</span>(<span class="params">e, terminal</span>) &#123;</span><br><span class="line">                e.<span class="title function_">preventDefault</span>();</span><br><span class="line">                terminal.<span class="title function_">inputFocus</span>();</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">desc</span>: <span class="string">&quot;查看上一条命令&quot;</span>,</span><br><span class="line">            <span class="attr">code</span>: <span class="string">&quot;ArrowUp&quot;</span>,</span><br><span class="line">            <span class="attr">keyDesc</span>: <span class="string">&quot;↑&quot;</span>,</span><br><span class="line">            <span class="title function_">action</span>(<span class="params">e, terminal</span>) &#123;</span><br><span class="line">                e.<span class="title function_">preventDefault</span>();</span><br><span class="line">                terminal.<span class="title function_">showPrevCommand</span>();</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">desc</span>: <span class="string">&quot;查看下一条命令&quot;</span>,</span><br><span class="line">            <span class="attr">code</span>: <span class="string">&quot;ArrowDown&quot;</span>,</span><br><span class="line">            <span class="attr">keyDesc</span>: <span class="string">&quot;↓&quot;</span>,</span><br><span class="line">            <span class="title function_">action</span>(<span class="params">e, terminal</span>) &#123;</span><br><span class="line">                e.<span class="title function_">preventDefault</span>();</span><br><span class="line">                terminal.<span class="title function_">showNextCommand</span>();</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Tab补全快捷键"><a href="#Tab补全快捷键" class="headerlink" title="Tab补全快捷键"></a>Tab补全快捷键</h3><p>判断hint是否有值，有值就将其赋给当前输入框，即InputCommand中的text(因为InputCommand的text属性和输入框双向绑定)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setTabPatching</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (hint.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="title class_">InputCommand</span>.<span class="property">value</span>.<span class="property">text</span> = <span class="string">`<span class="subst">$&#123;hint.value.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]&#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">      hint.value.split(<span class="string">&quot; &quot;</span>).length &gt; <span class="number">1</span> ? <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">    &#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随即在快捷键列表注册即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">shortcutList</span>: shortcut[] = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="string">&quot;Tab&quot;</span>,</span><br><span class="line">        <span class="attr">desc</span>: <span class="string">&quot;快捷键补齐&quot;</span>,</span><br><span class="line">        <span class="title function_">action</span>(<span class="params">e, terminal</span>) &#123;</span><br><span class="line">            e.<span class="title function_">preventDefault</span>();</span><br><span class="line">            <span class="keyword">if</span> (terminal.<span class="title function_">isInputFocus</span>()) &#123;</span><br><span class="line">                terminal.<span class="title function_">setTabPatching</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="历史命令（快捷键↑和↓实现）"><a href="#历史命令（快捷键↑和↓实现）" class="headerlink" title="历史命令（快捷键↑和↓实现）"></a>历史命令（快捷键↑和↓实现）</h2><p>使用快捷键可查看上一条或者下一条命令，具体快捷键注册在上面已经讲过了。而历史命令的快捷键则是通过终端调用<strong>showPrevCommand</strong>和<strong>showPrevCommand</strong>方法去实现。接下来讲这两个方法的具体实现过程。</p><p>这两个方法都封装在<strong>useHistory</strong>这个hook中，定义在与YuTerminal.vue同级目录下。</p><p>这个hook接受两个参数，分别是commandList（命令列表，即输入的不为空的有效命令）和inputCommand（当前输入框对应的值），返回四个方法或值，<strong>commandHistoryPos</strong>（可以看作<strong>指针</strong>，用于<strong>指向当前查看的命令位置</strong>）、showPrevCommand、showPrevCommand、listCommandHistory（用于history命令）。</p><p>这里以showPrevCommand为例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 查看下一条历史命令</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">showNextCommand</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (commandHistoryPos.<span class="property">value</span> &lt; commandList.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 触发条件：指针指向命令列表最后一项之前的项时，此时指针长度小于命令列表长度，将其加1</span></span><br><span class="line"><span class="comment">       最后一次触发时：指针指向命令列表最后一项，此时指针长度等于命令列表长度减1</span></span><br><span class="line"><span class="comment">       因为指针先加1，再获取命令列表对应的值的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    commandHistoryPos.<span class="property">value</span>++;</span><br><span class="line">    <span class="comment">// 将当前文本框的赋值为命令列表中指针对应的值</span></span><br><span class="line">    inputCommand.<span class="property">value</span>.<span class="property">text</span> = commandList[commandHistoryPos.<span class="property">value</span>].<span class="property">text</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commandHistoryPos.<span class="property">value</span> === commandList.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 触发条件：指针指向命令列表最后一项时再点一次↓箭头，此时指针长度超过命令列表长度，指向当前输入的文本框，输入命令文本置为空</span></span><br><span class="line">    commandHistoryPos.<span class="property">value</span>++;</span><br><span class="line">    inputCommand.<span class="property">value</span>.<span class="property">text</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="help命令"><a href="#help命令" class="headerlink" title="help命令"></a>help命令</h2><p>help命令文件夹中有四个文件：CommandHelpBox.vue、HeloBox.vue、helpCommand.ts、heloUtils.ts。</p><h3 id="HelpBox-vue"><a href="#HelpBox-vue" class="headerlink" title="HelpBox.vue"></a>HelpBox.vue</h3><p>用于呈现所有的命令。</p><h3 id="helpCommand-ts"><a href="#helpCommand-ts" class="headerlink" title="helpCommand.ts"></a>helpCommand.ts</h3><p>help命令。</p><ul><li><p>defineAsyncComponent</p><p>用于异步加载一个组件，接收一个返回Promise的加载函数</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><p>因为import动态导入也返回一个Promise，所以大多数情况下和import一起使用。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./xxxx.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>当使用defineAsyncComponent异步加载组件时，可能会出现以下警告。</p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722144104460.png" alt="image-20230722144104460"></p><p>这是因为此时Vue接收了一个响应式的组件（看意思是这个，具体我也不清楚），所以需要使用markRaw（让其变为非响应式）或shallowRef（仅让其浅层为响应式）。如下所示。</p><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230722144616013.png" alt="image-20230722144616013"></p>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记</title>
      <link href="/2023/05/04/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/04/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。<br><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((right + left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>循环每个数组，将其平方，随后使用sort函数进行排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        nums[i] = <span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[i],<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>因为给的数组是升序的，所以可以定义两个指针——left和right，分别指向队头和队尾，然后判断两个值的大小，进行交换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []; <span class="comment">// 新数组</span></span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 新数组赋值从队尾开始，因为数组升序，最大的要么是负数的平方，要么是正数的平方</span></span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = nums.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// l指向对头,r指向队尾</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] * nums[l] &lt; nums[r] * nums[r])&#123; <span class="comment">// 当l的平方小于r的平方，将结果数组的队尾赋值为r的平方</span></span><br><span class="line">            result[len--] = nums[r]*nums[r];</span><br><span class="line">            r--; <span class="comment">// r向前移动一位</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 相反，当r的平方小于l的平方，将结果数组的队尾赋值为l的平方</span></span><br><span class="line">            result[len--] = nums[l]*nums[l];</span><br><span class="line">            l++; <span class="comment">// l向后移动一位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>采用滑动窗口，定义两个指针i和j，将窗口长度赋初值为Infinity，<strong>不断的调节子序列的起始位置和终止位置</strong></p><ul><li>当窗口中的和小于target时，j++</li><li>当窗口中的和大于等于target时，判断窗口的长度与之前相比是大还是小，小就赋值，大就跳过</li><li>i++，sum减去滑动窗口起始值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Infinity</span>; <span class="comment">// 结果值，赋值为极大值</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>; <span class="comment">// 滑动窗口中所有值的和</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>; <span class="comment">// 滑动窗口起始指针</span></span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span>; <span class="comment">// 滑动窗口长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>;end &lt; nums.<span class="property">length</span>;end++)&#123;</span><br><span class="line">        sum += nums[end]; <span class="comment">// 当sum小于target时，继续循环</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123; <span class="comment">// 大于target时，进入循环</span></span><br><span class="line">            len = end - start + <span class="number">1</span>;  <span class="comment">// 获取滑动窗口的长度</span></span><br><span class="line">            result = result &gt; len ? len : result; <span class="comment">// 如果大于之前的值，则忽视，如果小，则将其赋给result</span></span><br><span class="line">            sum -= nums[start++]; <span class="comment">// 滑动窗口向后滑动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> result === <span class="title class_">Infinity</span> ? <span class="number">0</span> : result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵"></a>59.螺旋矩阵</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><ul><li><p>生成一个 n×n 空矩阵 res，随后模拟整个向内环绕的填入过程：</p><ul><li>定义当前左右上下边界 l,r,t,b，初始值 num &#x3D; 1，迭代终止值 tar &#x3D; n * n；</li><li>当 num &lt;&#x3D; tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：<ul><li>执行 num +&#x3D; 1：得到下一个需要填入的数字；</li><li><strong>更新边界</strong>：例如从左到右填完后，上边界 t +&#x3D; 1，相当于上边界向内缩 1。</li></ul></li><li>使用num &lt;&#x3D; tar而不是l &lt; r || t &lt; b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</li></ul></li><li><p>最终返回res 即可。</p></li></ul><p><img src="https://pic.leetcode-cn.com/ccff416fa39887c938d36fec8e490e1861813d3bba7836eda941426f13420759-Picture1.png" alt="Picture1.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = <span class="number">0</span>, right = n - <span class="number">1</span>, bottom = n - <span class="number">1</span>, left = <span class="number">0</span>; <span class="comment">// 定义边界</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>,target = n*n; <span class="comment">// 设置初值和结束值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)); <span class="comment">// 创建一个N*N的二维数组</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt;= target)&#123; <span class="comment">// 当num小于target时，进入循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = left;i &lt;= right;i++)&#123; <span class="comment">// 从左往右，循环后一层top已填满</span></span><br><span class="line">            res[top][i] = num++; <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">        top++; <span class="comment">// top加1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = top;i &lt;= bottom;i++)&#123; <span class="comment">// 从上往下，循环后一列right已填满</span></span><br><span class="line">            res[i][right] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;<span class="comment">// right加1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = right;i &gt;= left;i--)&#123; <span class="comment">// 从右往左，循环后一层bottom已填满</span></span><br><span class="line">            res[bottom][i] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;<span class="comment">// bottom减1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = bottom;i &gt;= top;i--)&#123; <span class="comment">// 从下往上，循环后一列left已填满</span></span><br><span class="line">            res[i][left] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;<span class="comment">// left加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><h3 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h3><p>创建虚拟头节点，创建两个指针，第一个h指向虚拟头节点，第二个fast指向head节点，随后<strong>以fast不为null作为循环条件</strong>，</p><ul><li>当<strong>fast.val</strong>与给定值相等时，将h指向fast的下一个节点</li><li>不相等，将h和fast都指向下一个节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">let</span> h = ret;</span><br><span class="line">    <span class="keyword">let</span> fast = h.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.<span class="property">val</span> === val)&#123;</span><br><span class="line">            h.<span class="property">next</span> = fast.<span class="property">next</span>;</span><br><span class="line">            fast = fast.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fast = fast.<span class="property">next</span>;</span><br><span class="line">            h = h.<span class="property">next</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者只用一个节点。</p><ul><li>cur指向虚拟头节点，循环条件为cur.next不为null</li><li>当cur.next的值等于val时，将其<strong>next指针指向cur.next.next</strong>，然后用<strong>continue跳出循环</strong></li><li>如果<strong>不等于</strong>，<strong>cur指向下一个节点</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">let</span> cur = ret;</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span> === val)&#123;</span><br><span class="line">            cur.<span class="property">next</span> = cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><p>让一个指针slow指向头节点，另一个fast指向头节点的下一个节点，然后进入循环，条件是fast不为null。</p><ul><li>定义一个中间变量保存fast.next，不保存的话当进行反转时，fast.next就无法获取到了</li><li>随后进行反转</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span>) <span class="keyword">return</span> head; <span class="comment">// 容错，当head为null，直接返回head</span></span><br><span class="line">    <span class="keyword">let</span> slow = head,fast = head.<span class="property">next</span>;</span><br><span class="line">    slow.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> next = fast.<span class="property">next</span>; <span class="comment">// 定义一个中间变量保存fast.next</span></span><br><span class="line">        fast.<span class="property">next</span> = slow; <span class="comment">// 快指针指向慢指针</span></span><br><span class="line">        slow = fast; <span class="comment">// 慢指针赋值为快指针</span></span><br><span class="line">        fast = next; <span class="comment">// 快指针等于保存的fast.next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>将所有节点存储栈中，随后创建一个虚拟头节点，不断从栈顶取出元素，将头节点.next指向取出的元素。<img src="https://raw.githubusercontent.com/liyuxuan7762/MyImageOSS/master/md_images/image-20230117195418626.png" alt="image-20230117195418626"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> h = head;</span><br><span class="line">    <span class="keyword">while</span>(h)&#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(h);</span><br><span class="line">        h = h.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> list = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 定义新的链表</span></span><br><span class="line">    h = list; <span class="comment">// h指向新链表</span></span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>(); <span class="comment">// 不断从栈顶取出元素</span></span><br><span class="line">        h.<span class="property">next</span> = node; <span class="comment">// h.next指向取出来的元素 </span></span><br><span class="line">        h = h.<span class="property">next</span>; <span class="comment">// h 赋值为hnext</span></span><br><span class="line">    &#125;</span><br><span class="line">    h.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="虚拟头节点-1"><a href="#虚拟头节点-1" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h3><p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt="24.两两交换链表中的节点1"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head), temp = ret;<span class="comment">// 创建新的虚拟节点</span></span><br><span class="line">    <span class="keyword">while</span>(temp.<span class="property">next</span> &amp;&amp; temp.<span class="property">next</span>.<span class="property">next</span>)&#123; <span class="comment">// 循环条件为temp的next和next.next不为空</span></span><br><span class="line">        <span class="keyword">let</span> pre = temp.<span class="property">next</span>,cur = temp.<span class="property">next</span>.<span class="property">next</span>; <span class="comment">// 暂存两个需要交换的节点</span></span><br><span class="line">        temp.<span class="property">next</span> = cur; <span class="comment">// 进行交换</span></span><br><span class="line">        pre.<span class="property">next</span> = cur.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span> = pre;</span><br><span class="line">        temp = pre; <span class="comment">// 此时pre交换为链表的第二个节点，将temp赋值为pre，用于进入下个循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><ul><li>定义fast指针和slow指针，初始值为虚拟头结点，如图：</li></ul><p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png" alt="img"></p><ul><li>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： <img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png" alt="img"></li><li>fast和slow同时移动，直到fast指向末尾，如题： <img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png" alt="img"></li><li>删除slow指向的下一个节点，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png" alt="img"></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">let</span> fast = ret, slow = ret;</span><br><span class="line">    <span class="keyword">while</span>(n--) fast = fast.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast.<span class="property">next</span>)&#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.<span class="property">next</span> = slow.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>将链表headA的所有节点存在map中，循环链表headB，与map做判断，找得到则直接返回，找不到返回null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">while</span>(headA !== <span class="literal">null</span>)&#123;</span><br><span class="line">        map.<span class="title function_">set</span>(headA, <span class="number">1</span>);</span><br><span class="line">        headA = headA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headB !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(headB))  <span class="keyword">return</span> headB;</span><br><span class="line">        headB = headB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h3 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h3><p>将所有节点存入map，key为节点，value为出现的次数。</p><ul><li>如果获取到的节点的value为1，则说明是循环链表的入口，直接返回</li><li>否则继续循环</li><li>如果出了循环，说明不是循环链表，返回null</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">let</span> hashmap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">while</span>(p !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="title function_">get</span>(p) === <span class="number">1</span>) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hashmap.<span class="title function_">set</span>(p, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><img src="https://code-thinking.cdn.bcebos.com/gifs/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif" alt="141.环形链表"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow = head.<span class="property">next</span>, fast = head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span> &amp;&amp; fast !== slow)&#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast.<span class="property">next</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow !== fast)&#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="循环逐个相加"><a href="#循环逐个相加" class="headerlink" title="循环逐个相加"></a>循环逐个相加</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> addOne = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="keyword">let</span> head = sum; <span class="comment">// 保存头节点，便于返回</span></span><br><span class="line">    <span class="keyword">while</span>(addOne || l1 || l2)&#123;</span><br><span class="line">        <span class="comment">// l1、l2长度不定，所以可能一个已经为空了，另一个还存在，所以需要判断是否为空，为空则赋0，不为空则是它的val</span></span><br><span class="line">        <span class="keyword">let</span> val1 = l1 ? l1.<span class="property">val</span> : <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">let</span> val2 = l2 ? l2.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单个位相加，要加上进位</span></span><br><span class="line">        <span class="keyword">let</span> r1 = val1 + val2 + addOne;</span><br><span class="line">        <span class="comment">// 判断相加后的结果是不是大于0，大于0则进位赋值为1，否则为0</span></span><br><span class="line">        addOne = r1 &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 定义新节点，连接虚拟头节点的next</span></span><br><span class="line">        sum.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(r1 % <span class="number">10</span> );</span><br><span class="line">        sum = sum.<span class="property">next</span>;</span><br><span class="line">        <span class="comment">// 如果l1或l2有next节点，则将其赋为它的next节点</span></span><br><span class="line">        <span class="keyword">if</span>(l1) l1 = l1.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(l2) l2 = l2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>双层循环，外循环判断当前值是否等于val，内循环将数组从当前值开始，不断将后面的值往前挪一格。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] === val)&#123; <span class="comment">// 当循环到等于val的值时，再进行一次循环，将i以后的元素都往前移一位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">                nums[j-<span class="number">1</span>] = nums[j]; </span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// 因为i以后的数值都往前移了一位，所以i也向前移动一位</span></span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>定义一个fast和slow指针，for循环遍历，当前值不等于val时，快慢指针同时递增，而相等时，快指针继续递增，慢指针停止递增,当不相等时，当前慢指针所对应的val值就会被快指针对应的值覆盖。</p><ul><li>快指针：<strong>寻找新数组的元素</strong> ，新数组就是不含有目标元素的数组</li><li>慢指针：指向<strong>更新 新数组下标</strong>的位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> slow = <span class="number">0</span>; <span class="comment">// 慢指针，用于指向新数组的下标</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> fast = <span class="number">0</span>;fast &lt; nums.<span class="property">length</span>;fast++)&#123; <span class="comment">// 快指针，用于寻找新数组的元素</span></span><br><span class="line">    <span class="keyword">if</span>(nums[fast] !== val)&#123; <span class="comment">// 当快指针对应的值不等于val时,将慢指针对应的值赋值为快指针对应的值</span></span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><h4 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h4><ol><li><p><strong>如何移除字符串中多余的空格</strong><br>双指针法：这里的处理就跟以前有一道数组题移除元素的方法是类似的，首先我们定义两个指针，初始都指向数组的0下标,快指针每一次向前移动的时候判断当前元素是否是一个空格，如果不是那么就把当前元素赋值给慢指针所指向的位置，然后快慢指针同时往前移动一步，<strong>这里需要注意一下，因为两个不同的单词之间需要一个空格，所以我们必须需要判断slow指针是否指向字符串数组第一个下标(因为第一个单词前面不需要空格)，然后接下来每一次都让slow指向的位置都赋值为空格，这样两个不同的单词之间就会产生一个空格了</strong></p></li><li><p><strong>如何将处理后的字符串整体翻转</strong><br><strong>双指针法</strong>：只需要定义两个指针，分别指向数组的头部和尾部的位置，然后一起往中间靠拢，相互调换位置即可</p></li><li><p><strong>如何对单个单词进行翻转</strong><br><strong>双指针法</strong>：(如：”drlow ollhe”),我们可以轻易发现字符串中的空格跟最后一个单词的最后一个字符的位置就是每一次置换位置的判断条件；所以通过第二部的函数合理控制好边界就可以完成每一个单词的翻转</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">removeExtraSpaces</span>(<span class="params">s</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;fast &lt; s.<span class="property">length</span>;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[fast] !== <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(slow !== <span class="number">0</span>)&#123;</span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(fast &lt; s.<span class="property">length</span> &amp;&amp; s[fast] !== <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                    s[slow] = s[fast];</span><br><span class="line">                    fast++;</span><br><span class="line">                    slow++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="property">length</span> = slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reverseWords</span>(<span class="params">s, start, end</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> slow = start, fast = end;</span><br><span class="line">        <span class="keyword">while</span>(slow &lt; fast)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = s[slow];</span><br><span class="line">            s[slow] = s[fast];</span><br><span class="line">            s[fast] = temp;</span><br><span class="line">            slow ++;</span><br><span class="line">            fast --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">    <span class="title function_">removeExtraSpaces</span>(arr);</span><br><span class="line">    <span class="title function_">reverseWords</span>(arr, <span class="number">0</span> ,arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt;= arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] === <span class="string">&#x27; &#x27;</span> || i === arr.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="title function_">reverseWords</span>(arr, begin, i - <span class="number">1</span>);</span><br><span class="line">            begin = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>遍历数组，将每一个元素转换成字符数组，进行排序，将排序后的字符作为哈希表的key，如果是异位词，那么排序后的字符数组也是相同的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> strs)&#123;</span><br><span class="line">        <span class="keyword">let</span> sArr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);<span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">        sArr.<span class="title function_">sort</span>();<span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">let</span> key = sArr.<span class="title function_">toString</span>(); <span class="comment">// 获取排序后的字符串形式</span></span><br><span class="line">        <span class="keyword">let</span> list = map.<span class="title function_">get</span>(key) ? map.<span class="title function_">get</span>(key) : <span class="keyword">new</span> <span class="title class_">Array</span>();<span class="comment">// 如果map有了list就用原来的，没有就新创建一个</span></span><br><span class="line">        list.<span class="title function_">push</span>(s);<span class="comment">// 将字符推入list</span></span><br><span class="line">        map.<span class="title function_">set</span>(key, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(map.<span class="title function_">values</span>())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">que1</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">que2</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">que1</span>.<span class="title function_">push</span>(x); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">que1</span>.<span class="property">length</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i++)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">que2</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">que1</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">que1</span>.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="variable language_">this</span>.<span class="property">que2</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span>  num = (<span class="variable language_">this</span>.<span class="property">que1</span>.<span class="property">length</span> === <span class="number">0</span>) ? <span class="variable language_">this</span>.<span class="property">que1</span>[<span class="variable language_">this</span>.<span class="property">que1</span>.<span class="property">length</span>-<span class="number">1</span>] : <span class="variable language_">this</span>.<span class="property">que1</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">que1</span>.<span class="property">length</span> === <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">que2</span>.<span class="property">length</span> === <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">que1</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">que2</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">que1</span>.<span class="title function_">push</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">que1</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">que1</span>[<span class="variable language_">this</span>.<span class="property">que1</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">que1</span>.<span class="property">length</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">que2</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    s = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> right = [<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;]&#x27;</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!right.<span class="title function_">includes</span>(s[i]))&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&#125;&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.<span class="property">length</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 20000</code></li><li><code>S</code> 仅由小写英文字母组成。</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    stack.<span class="title function_">push</span>(s[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> x = stack.<span class="title function_">pop</span>();</span><br><span class="line">        x === s[i] ? <span class="literal">true</span> : stack.<span class="title function_">push</span>(x,s[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遇到数字入栈，遇到运算符号取出栈顶前两个元素，进行对应的运算，再将运算结果推入栈中，进行下一次运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> op = [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> tokens)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(!op.<span class="title function_">includes</span>(i))&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="title class_">Number</span>(i));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> num1 = stack.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">let</span> num2 = stack.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">let</span> res;</span><br><span class="line">            <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    res = num1+num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    res = num2-num1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    res = num1*num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    res = num2/num1 | <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.<span class="title function_">push</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="347-前K个高频元素"><a href="#347-前K个高频元素" class="headerlink" title="347.前K个高频元素"></a>347.前K个高频元素</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>用map记录每一个数和对应出现的次数，然后将其转换为数组根据<strong>value</strong>进行降序排序，将前k个值推入结果数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;<span class="comment">//用map记录每一个数和对应出现的次数</span></span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(i))&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(i, map.<span class="title function_">get</span>(i) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mapArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(map);<span class="comment">//降序排序</span></span><br><span class="line">    mapArr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">        result.<span class="title function_">push</span>(mapArr[i][<span class="number">0</span>]);<span class="comment">//将前k个值推入结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> stack = []; <span class="comment">// 定义栈</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result; <span class="comment">// 容错，如果root为空直接返回空数组</span></span><br><span class="line">    stack.<span class="title function_">push</span>(root); </span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">        result.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">        node.<span class="property">right</span> &amp;&amp; stack.<span class="title function_">push</span>(node.<span class="property">right</span>); <span class="comment">// 先推入右节点再推入左节点因为栈先进后出，为了先输出左节点</span></span><br><span class="line">        node.<span class="property">left</span> &amp;&amp; stack.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result; <span class="comment">// 容错，如果root为空直接返回空数组</span></span><br><span class="line">    <span class="keyword">let</span> cur = root; <span class="comment">// 定义一个指针节点</span></span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(cur !== <span class="literal">null</span> || stack.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123; <span class="comment">// 因为中序遍历是要先遍历左节点，所以将所有左节点推入栈</span></span><br><span class="line">            stack.<span class="title function_">push</span>(cur);</span><br><span class="line">            cur = cur.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>(); <span class="comment">// 从栈中取出栈顶元素，也就是最底最左的节点</span></span><br><span class="line">        result.<span class="title function_">push</span>(node.<span class="property">val</span>); <span class="comment">// 将其推入结果数组</span></span><br><span class="line">        cur = node.<span class="property">right</span>; <span class="comment">// cur赋值为node的右节点，继续进入循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h2><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><p>先将二叉树进行中右左遍历，再将结果反转就是左右中后续遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    stack.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">        result.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">       <span class="comment">// 改变节点推入顺序，先推入左节点，将遍历顺序变为中右左</span></span><br><span class="line">        node.<span class="property">left</span> &amp;&amp; stack.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">        node.<span class="property">right</span> &amp;&amp; stack.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果反转</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">reverse</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="迭代-3"><a href="#迭代-3" class="headerlink" title="迭代"></a>迭代</h3><p>采用<strong>队列</strong>，将根节点推入队列，每次计算<strong>当前层的长度len</strong>，循环len次，从队列中取出当前层的节点，将值推入结果数组，同时<strong>判断当前节点有没有孩子节点</strong>，有的话将孩子节点推入队列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> queue;</span><br><span class="line">    queue.<span class="title function_">push</span>(root);<span class="comment">// 将根节点推入队列</span></span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;<span class="comment">// 循环条件为队列不为空</span></span><br><span class="line">        <span class="keyword">let</span> len = queue.<span class="property">length</span>;<span class="comment">// 获取队列长度（即当前层的长度）</span></span><br><span class="line">        <span class="keyword">let</span> curLevel = [];<span class="comment">// 当前节点存放的数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;<span class="comment">// 将当前层所有节点取出</span></span><br><span class="line">            <span class="keyword">let</span> cur = queue.<span class="title function_">shift</span>();<span class="comment">// 采用shift，队列先进先出</span></span><br><span class="line">            curLevel.<span class="title function_">push</span>(cur.<span class="property">val</span>);<span class="comment">// 将节点的val推入数组</span></span><br><span class="line">            <span class="comment">// 当且仅当当前节点有孩子节点才将其孩子节点推入数组</span></span><br><span class="line">            cur.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">            cur.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(curLevel);<span class="comment">// 将当前层的节点值推入最后的结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>采用先序遍历，先判断当前二叉树是否是null，是的话就返回null，遍历交换当前节点的左右节点，然后再递归，将左右节点分别传入函数，最后返回root二叉树。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> left  = root.<span class="property">left</span>;<span class="comment">//用变量获取左右节点</span></span><br><span class="line">    <span class="keyword">let</span> right = root.<span class="property">right</span>;</span><br><span class="line">    root.<span class="property">left</span> = right;<span class="comment">//交换左右节点</span></span><br><span class="line">    root.<span class="property">right</span> = left;</span><br><span class="line">    <span class="title function_">invertTree</span>(root.<span class="property">left</span>);<span class="comment">//将左右节点传入函数进行递归交换</span></span><br><span class="line">    <span class="title function_">invertTree</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-4"><a href="#迭代-4" class="headerlink" title="迭代"></a>迭代</h3><p>采用栈存储当前节点，循环条件是栈的长度不为0。然后定义变量存储出栈的值，判断变量是否为null，是的话跳过本次循环，不是则交换左右节点。将左右节点再推入栈中,直到栈为空。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    stack.<span class="title function_">push</span>(root);<span class="comment">//将根节点存储栈中</span></span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> t = stack.<span class="title function_">pop</span>();<span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果t为空，则跳过本次循环，不交换</span></span><br><span class="line">        <span class="keyword">let</span> left = t.<span class="property">left</span>;<span class="comment">//分别用变量存储左右节点</span></span><br><span class="line">        <span class="keyword">let</span> right = t.<span class="property">right</span>;</span><br><span class="line">        t.<span class="property">left</span> = right;<span class="comment">//将t的左右节点进行交换</span></span><br><span class="line">        t.<span class="property">right</span> = left;</span><br><span class="line">        stack.<span class="title function_">push</span>(t.<span class="property">left</span>);<span class="comment">//将交换后的左右节点再推入栈中，进入循环</span></span><br><span class="line">        stack.<span class="title function_">push</span>(t.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>子树堆成条件：</p><ol><li><strong>它们两个根节点具有相同的值</strong> </li><li><strong>每个树的右子树都与另一个树的左子树镜像对称</strong></li></ol><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>通过递归判断，第一次将树的根传两次进去，然后第二次传根的left和right进行判断，第三次传根left的left和根right的right以及根left的right和根right的left进行比较….以此类推，直到到树的底层为止</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span></span><br><span class="line">    <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val?: <span class="built_in">number</span>, left?: TreeNode | <span class="literal">null</span>, right?: TreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = (left===<span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = (right===<span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归判断二叉树是否对称</span></span><br><span class="line"><span class="keyword">const</span> check = (<span class="attr">p</span>:<span class="title class_">TreeNode</span>|<span class="literal">null</span>,<span class="attr">q</span>:<span class="title class_">TreeNode</span>|<span class="literal">null</span>):<span class="function"><span class="params">boolean</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断两个节点是否同时不存在，不存在返回true</span></span><br><span class="line">    <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果只有一个不存在，说明不对称，返回false</span></span><br><span class="line">    <span class="keyword">return</span> p.<span class="property">val</span> === q.<span class="property">val</span> &amp;&amp; <span class="title function_">check</span>(p.<span class="property">left</span>,q.<span class="property">right</span>) &amp;&amp; <span class="title function_">check</span>(p.<span class="property">right</span>,q.<span class="property">left</span>); <span class="comment">//第一个条件是两个节点的值是否相等，第二个条件是将左节点的左儿子和右节点的右儿子进行比较，第三个条件是将左节点的右儿子和右节点的左儿子进行比较</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSymmetric</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">check</span>(root,root);<span class="comment">//首次传两个根节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//好理解的方法</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isSymmetry</span> = (<span class="params">left, right</span>) =&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!left &amp;&amp; right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left.<span class="property">val</span> !== right.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> isLeftTrue = <span class="title function_">isSymmetry</span>(left.<span class="property">left</span>,right.<span class="property">right</span>);</span><br><span class="line">        <span class="keyword">let</span> isRightTrue = <span class="title function_">isSymmetry</span>(left.<span class="property">right</span>, right.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">return</span> isLeftTrue &amp;&amp; isRightTrue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isSymmetry</span>(root.<span class="property">left</span>, root.<span class="property">right</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-5"><a href="#迭代-5" class="headerlink" title="迭代"></a>迭代</h3><p>使用队列，创建一个队列，先推入两次根节点，随后进行循环（循环条件是队列的长度），两次取出队列的值进行判断，如果两个节点都为空说明这两个节点是对称的，设置为continue，如果两个节点有一个为空或者它们的val值不相等，则返回false。然后分别推入节点的左儿子和另一个节点的右儿子，以及节点的右儿子和另一个节点的左儿子，再次进入循环。循环结束，返回true。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> check = (<span class="attr">u</span>:<span class="title class_">TreeNode</span>|<span class="literal">null</span> , <span class="attr">v</span>:<span class="title class_">TreeNode</span>|<span class="literal">null</span>):<span class="function"><span class="params">boolean</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">q</span>:<span class="title class_">TreeNode</span>[] = [];<span class="comment">//创建队列</span></span><br><span class="line">    q.<span class="title function_">push</span>(u);<span class="comment">//推入根节点两次，因为要分别判断根的left和right</span></span><br><span class="line">    q.<span class="title function_">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="property">length</span>)&#123;<span class="comment">//进行循环</span></span><br><span class="line">        u = q.<span class="title function_">shift</span>();<span class="comment">//取出队列的前两个值进行判断</span></span><br><span class="line">        v = q.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!u &amp;&amp; !v) <span class="keyword">continue</span>;<span class="comment">//如果它们都为空说明是对称的，结束本次循环进入下次循环</span></span><br><span class="line">        <span class="keyword">if</span>((!u || !v) || u.<span class="property">val</span> != v.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果它们有一个为空，或者值不相等，返回false</span></span><br><span class="line"><span class="comment">//推入u的left和v的right，u的right和v的left，因为它们镜像，要比对的是它们的值</span></span><br><span class="line">        q.<span class="title function_">push</span>(u.<span class="property">left</span>);</span><br><span class="line">        q.<span class="title function_">push</span>(v.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">        q.<span class="title function_">push</span>(u.<span class="property">right</span>);</span><br><span class="line">        q.<span class="title function_">push</span>(v.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//循环结束，说明是对称的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSymmetric</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">check</span>(root,root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>如果我们知道了左子树和右子树的最大深度 l和 r，那么该二叉树的最大深度即为<strong>max⁡(l,r)+1</strong><br>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时返回0退出。</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/solutions/349250/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/">104. 二叉树的最大深度 - 力扣（Leetcode）</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">deep</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> left = <span class="title function_">deep</span>(root.<span class="property">left</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> right = <span class="title function_">deep</span>(root.<span class="property">right</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">deep</span>(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-6"><a href="#迭代-6" class="headerlink" title="迭代"></a>迭代</h3><p>二叉树的最大深度就是它对应的层数，可以使用层序遍历来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = []</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;<span class="comment">// 表示层数的值</span></span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        index++;<span class="comment">// 每次遍历当层index++</span></span><br><span class="line">        <span class="keyword">let</span> len = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = queue.<span class="title function_">shift</span>();</span><br><span class="line">            cur.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">            cur.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>就是找到第一叶子节点所在的层次。</p><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><p>大致上与最大深度一样，只不过存在特殊可能，当二叉树根节点的左子树或右子树为空时，照着最大深度做会把根节点所在的层当最最小深度返回，显然是不对的，所以在最后需要进行判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">minDepth</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">minDepth</span>(root.<span class="property">left</span>) + <span class="number">1</span>;<span class="comment">// 获取左节点的深度</span></span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">minDepth</span>(root.<span class="property">right</span>) + <span class="number">1</span>;<span class="comment">// 获取右节点的深度</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right ; <span class="comment">// 这是为了判断当根节点的左子树为空时，直接返回右子树的深度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">left</span> !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;<span class="comment">// 这是为了判断当根节点的右子树为空时，直接返回左子树的深度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(left,right); <span class="comment">// 当根节点左右子树不为空时，这是可以返回left和right的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">minDepth</span>(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-7"><a href="#迭代-7" class="headerlink" title="迭代"></a>迭代</h3><p>与最大深度的迭代方法差不多，使用层序遍历，只是最后循环当前层的时候最后一个条件为<strong>如果当前节点的左右节点都为空时，直接返回计算的index</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">let</span> len = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = queue.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur.<span class="property">left</span>) queue.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">            <span class="keyword">if</span>(cur.<span class="property">right</span>) queue.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">            <span class="keyword">if</span>(!cur.<span class="property">left</span> &amp;&amp; !cur.<span class="property">right</span>) <span class="keyword">return</span> index;<span class="comment">// 如果左右孩子为空，说明是叶子节点，即到最小深度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><p><strong>二叉树的高度指当前节点到叶子节点的边条数，力扣中指当前节点到叶子节点的节点个数</strong></p><p>采用<strong>后序遍历</strong>，如果当前节点的左右节点的高度差的绝对值大于1，<strong>返回-1</strong>，小于等一1则返回它的当前节点的高度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isBalanced = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">Balance</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 递归中值条件</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title class_">Balance</span>(root.<span class="property">left</span>);<span class="comment">// 计算左子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(left === -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 如果左子树不为平衡二叉树返回-1</span></span><br><span class="line">        <span class="keyword">let</span> right = <span class="title class_">Balance</span>(root.<span class="property">right</span>);<span class="comment">// 计算右子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(right === -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 如果右子树不为平衡二叉树返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(left, right); <span class="comment">// 判断 如果左子树的高度减去右子树的高度的绝对值大于1，返回-1，否则返回当前节点的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="title class_">Balance</span>(root) === -<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h2><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[&quot;1&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str =<span class="string">&quot;&quot;</span>;<span class="comment">// 路径字符串</span></span><br><span class="line">    <span class="keyword">let</span> result = [];<span class="comment">// 结果数组</span></span><br><span class="line">    <span class="comment">// 递归参数为节点和表示路径的str字符串</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">path</span> = (<span class="params">root, str</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件为当前节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 结果数组推入字符串加上当前节点的值的字符串</span></span><br><span class="line">            result.<span class="title function_">push</span>(str+root.<span class="property">val</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str +=root.<span class="property">val</span>+<span class="string">&#x27;-&gt;&#x27;</span>;<span class="comment">// 单层循环中str加上当前值和-&gt;箭头</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>)&#123; <span class="comment">// 如果当前节点左孩子不为空，则进入递归</span></span><br><span class="line">            <span class="title function_">path</span>(root.<span class="property">left</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>)&#123;<span class="comment">// 如果当前节点右孩子不为空，则进入递归</span></span><br><span class="line">            <span class="title function_">path</span>(root.<span class="property">right</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">path</span>(root, str);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h2><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,9,20,null,null,15,7] </span><br><span class="line">输出: 24 </span><br><span class="line">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数在 <code>[1, 1000]</code> 范围内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h3><p>递归结束条件根据父节点判断左孩子节点是否为叶子节点。</p><p>即<code>if(root.left &amp;&amp; !root.left.left &amp;&amp; !root.left.right)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">leftLeave</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">let</span> leftValue = <span class="title function_">leftLeave</span>(root.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span> &amp;&amp; !root.<span class="property">left</span>.<span class="property">left</span> &amp;&amp; !root.<span class="property">left</span>.<span class="property">right</span>)&#123;</span><br><span class="line">            leftValue += root.<span class="property">left</span>.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> rightValue = <span class="title function_">leftLeave</span>(root.<span class="property">right</span>);</span><br><span class="line">        <span class="keyword">return</span> leftValue + rightValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">leftLeave</span>(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-8"><a href="#迭代-8" class="headerlink" title="迭代"></a>迭代</h3><p>层次遍历每个节点，用递归的判断条件即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    queue.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> cur = queue.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="comment">// 判断是不是左叶子节点的条件</span></span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">left</span> &amp;&amp; !cur.<span class="property">left</span>.<span class="property">left</span> &amp;&amp; !cur.<span class="property">left</span>.<span class="property">right</span>)&#123;</span><br><span class="line">            num += cur.<span class="property">left</span>.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">        cur.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>只需找<strong>树最后一层的第一个节点</strong>即可，使用队列将树每一层进行遍历，然后不断将第一个节点赋给结果值result，遍历结束，result就是想要的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> queue = [];</span><br><span class="line">   <span class="keyword">let</span> result;</span><br><span class="line">   queue.<span class="title function_">push</span>(root); <span class="comment">// 根节点入队</span></span><br><span class="line">   <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> len = queue.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123; <span class="comment">// 每一层进行遍历</span></span><br><span class="line">        <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>(); </span><br><span class="line">        <span class="keyword">if</span>(i === <span class="number">0</span>) result = node.<span class="property">val</span>; <span class="comment">// 找每一层的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h2><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> sum = targetSum;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">findPath</span> = (<span class="params">root, sum</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span> &amp;&amp; sum === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">findPath</span>(root.<span class="property">left</span>, sum - root.<span class="property">left</span>.<span class="property">val</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">findPath</span>(root.<span class="property">right</span>, sum - root.<span class="property">right</span>.<span class="property">val</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">findPath</span>(root, sum - root.<span class="property">val</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用flag"><a href="#使用flag" class="headerlink" title="使用flag"></a>使用flag</h3><p>定义flag变量，初始为false。</p><p>进入递归，值为节点root和sumbi表示当前节点到根节点的总和。</p><p>sum不断增加，当sum等于targetSum时，就把flag置为true。随即返回flag即可。</p><ul><li>flag为true，找到路径</li><li>flag为false，没找到</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>; <span class="comment">// 全局变量flag标志</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">findPath</span> = (<span class="params">root, sum</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 此时sum等于目标总和且为叶子节点，找到了路径,flag置为true</span></span><br><span class="line">        <span class="keyword">if</span>(sum === targetSum &amp;&amp; (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>))&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有左节点，左节点进入递归，sum值加上左节点的值</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>) <span class="title function_">findPath</span>(root.<span class="property">left</span>, sum + root.<span class="property">left</span>.<span class="property">val</span>);</span><br><span class="line">        <span class="comment">// 如果有右节点，右节点进入递归,sum值加上右节点的值</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>) <span class="title function_">findPath</span>(root.<span class="property">right</span>, sum + root.<span class="property">right</span>.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始sum加上根节点的值</span></span><br><span class="line">    <span class="title function_">findPath</span>(root, sum + root.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [-1], postorder = [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h3 id="分割中序、后序数组"><a href="#分割中序、后序数组" class="headerlink" title="分割中序、后序数组"></a>分割中序、后序数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span>(<span class="params">inorder, postorder</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(postorder.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> node = postorder[postorder.<span class="property">length</span> - <span class="number">1</span>]; <span class="comment">// 获取后序遍历的最后一个值作为根节点</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(node); <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">let</span> index = inorder.<span class="title function_">indexOf</span>(node); <span class="comment">// 获取中序遍历中node所在的位置</span></span><br><span class="line">    <span class="keyword">let</span> inLeft = inorder.<span class="title function_">slice</span>(<span class="number">0</span>, index); <span class="comment">// 对中序遍历进行分割，获取以该节点为根的所有左子树</span></span><br><span class="line">    <span class="keyword">let</span> inRight = inorder.<span class="title function_">slice</span>(index+<span class="number">1</span>); <span class="comment">// 分割以该节点为根的所有右子树</span></span><br><span class="line">    <span class="keyword">let</span> poLeft = postorder.<span class="title function_">slice</span>(<span class="number">0</span>,inLeft.<span class="property">length</span>); <span class="comment">// 对后序遍历进行分割，获取以该节点为根的所有左子树</span></span><br><span class="line">    <span class="keyword">let</span> poRight = postorder.<span class="title function_">slice</span>(inLeft.<span class="property">length</span>,postorder.<span class="property">length</span> - <span class="number">1</span>); <span class="comment">// 对后序遍历进行分割,获取以该节点为根的所有右子树</span></span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">buildTree</span>(inLeft, poLeft); <span class="comment">// 将分割好的左子树的中序、后序遍历数组传入函数进行递归</span></span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">buildTree</span>(inRight, poRight); <span class="comment">// 将分割好的右子树的中序、后序遍历数组传入函数进行递归</span></span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 返回根节点</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h2><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h3 id="获取最大值"><a href="#获取最大值" class="headerlink" title="获取最大值"></a>获取最大值</h3><p>每次递归都获取当前数组的最大值，然后根据其在数组中的位置进行分割左子树和右子树，进入递归。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 递归结束条件</span></span><br><span class="line">    <span class="keyword">let</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...nums); <span class="comment">// 获取当前数组的最大值作为根节点</span></span><br><span class="line">    <span class="keyword">let</span> index = nums.<span class="title function_">indexOf</span>(max); <span class="comment">// 找出最大节点在当前数组所在的索引</span></span><br><span class="line">    <span class="keyword">let</span> left = nums.<span class="title function_">slice</span>(<span class="number">0</span>,index); <span class="comment">// 根据找出的索引进行分割数组，分割左数组</span></span><br><span class="line">    <span class="keyword">let</span> right = nums.<span class="title function_">slice</span>(index+<span class="number">1</span>); <span class="comment">// 分割右数组</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(max); <span class="comment">// 根据最大值创建根节点</span></span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">constructMaximumBinaryTree</span>(left); <span class="comment">// 进入左子树递归</span></span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">constructMaximumBinaryTree</span>(right); <span class="comment">// 进入右子树递归</span></span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 最后返回根节点即可</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1], root2 = [1,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="keyword">function</span>(<span class="params">root1, root2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 递归结束条件，当root1和root2都为空时，返回null（不能直接一个return，否则返回的是undefined，会报错）</span></span><br><span class="line">    <span class="keyword">let</span> node; <span class="comment">// 定义节点</span></span><br><span class="line">    <span class="keyword">if</span>(root1 &amp;&amp; root2)&#123; <span class="comment">// 如果root1和root2同时存在，则节点的值为root1.val+root2.val</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.<span class="property">val</span> + root2.<span class="property">val</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root1 || root2)&#123; <span class="comment">// 如果root1和root2只存在一个，则节点的值为存在的那个的值</span></span><br><span class="line">        <span class="keyword">let</span> val = root1 ? root1.<span class="property">val</span> : root2.<span class="property">val</span>;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">left</span> =  <span class="title function_">mergeTrees</span>(root1 ? root1.<span class="property">left</span> : <span class="literal">null</span>,root2 ? root2.<span class="property">left</span> : <span class="literal">null</span>); <span class="comment">// 给node的左节点赋值，需要先判断root1或root2是否为null，因为它们有可能其中一个为空</span></span><br><span class="line">    node.<span class="property">right</span> = <span class="title function_">mergeTrees</span>(root1 ? root1.<span class="property">right</span> : <span class="literal">null</span>,root2 ? root2.<span class="property">right</span> : <span class="literal">null</span>);<span class="comment">// 给node的右节点赋值，同样要判断是否为空</span></span><br><span class="line">    <span class="keyword">return</span> node; <span class="comment">// 返回节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>数中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul><h3 id="递归-8"><a href="#递归-8" class="headerlink" title="递归"></a>递归</h3><p>设置一个节点值node，初始为null，然后递归寻找匹配的节点，如果找到直接将值赋给node，没找到node值为null，返回node。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchBST = <span class="keyword">function</span>(<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span>; <span class="comment">// 定义node，初始为null</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">findVal</span> = (<span class="params">root, val</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果没找到，返回</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> === val) node = root;  <span class="comment">// 找到，则将该节点赋给node</span></span><br><span class="line">        root.<span class="property">left</span> &amp;&amp; <span class="title function_">findVal</span>(root.<span class="property">left</span>, val); <span class="comment">// 不断进行左右子树的递归</span></span><br><span class="line">        root.<span class="property">right</span> &amp;&amp; <span class="title function_">findVal</span>(root.<span class="property">right</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">findVal</span>(root, val);</span><br><span class="line">    <span class="keyword">return</span> node; <span class="comment">// 最后返回node即可</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchBST = <span class="keyword">function</span>(<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root.<span class="property">val</span> === val) <span class="keyword">return</span> root; <span class="comment">// 当节点为空或者节点值等于val值时，返回</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &gt; val) <span class="keyword">return</span> <span class="title function_">searchBST</span>(root.<span class="property">left</span>, val); <span class="comment">// 当节点值大于val值，则将节点的左子树进入递归</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &lt; val) <span class="keyword">return</span> <span class="title function_">searchBST</span>(root.<span class="property">right</span>, val);<span class="comment">// 当节点值小于val值，则将节点的右子树进入递归</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-9"><a href="#迭代-9" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchBST = <span class="keyword">function</span>(<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(root !== <span class="literal">null</span>)&#123; <span class="comment">// 循环结束条件——root===Null</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &gt; val) root = root.<span class="property">left</span>; <span class="comment">// 当节点值大于val值，则将当前节点赋值为它的左孩子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="property">val</span> &lt; val) root = root.<span class="property">right</span>;<span class="comment">// 当节点值小于val值，则将当前节点赋值为它的右孩子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root; <span class="comment">// 剩下就只有相等的可能，所以直接返回节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 循环结束还没有返回则说明没有找到匹配的节点，返回null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历二叉树，将节点值存入数组。如果是二叉搜索树，那么数组一定是升序排列的，所以只需要遍历数组看是否升序即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 中序遍历，将所有的值存入数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">traversal</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">traversal</span>(root.<span class="property">left</span>);</span><br><span class="line">        result.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">        <span class="title function_">traversal</span>(root.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">traversal</span>(root);</span><br><span class="line">    <span class="comment">// 判断数组是否升序排列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; result.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result[i] &lt;= result[i - <span class="number">1</span>])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h3 id="map辅助"><a href="#map辅助" class="headerlink" title="map辅助"></a>map辅助</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMode = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">More</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 遍历树，将树的值存入map,key 为节点值，val为出现的次数</span></span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(root.<span class="property">val</span>)) map.<span class="title function_">set</span>(root.<span class="property">val</span>, map.<span class="title function_">get</span>(root.<span class="property">val</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> map.<span class="title function_">set</span>(root.<span class="property">val</span>, <span class="number">1</span>);</span><br><span class="line">        root.<span class="property">left</span> &amp;&amp; <span class="title class_">More</span>(root.<span class="property">left</span>);</span><br><span class="line">        root.<span class="property">right</span> &amp;&amp; <span class="title class_">More</span>(root.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">More</span>(root)</span><br><span class="line">    <span class="comment">// 先获取树的根节点值作为最大值</span></span><br><span class="line">    <span class="keyword">let</span> max = map.<span class="title function_">get</span>(root.<span class="property">val</span>);</span><br><span class="line">    <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> map.<span class="title function_">entries</span>())&#123;</span><br><span class="line">        <span class="comment">// 这是为了判断有多个出现次数最大的节点</span></span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(key) ===  max)&#123;</span><br><span class="line">            rootVal.<span class="title function_">push</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果值大于max，将结果数组置为空，并将其作为最大值，将其推入结果数组</span></span><br><span class="line">        <span class="keyword">if</span>(value &gt; max) &#123;</span><br><span class="line">            rootVal = [];</span><br><span class="line">            max = value;</span><br><span class="line">            rootVal.<span class="title function_">push</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootVal</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h3 id="递归-9"><a href="#递归-9" class="headerlink" title="递归"></a>递归</h3><p>递归函数：返回当前子树中 p 和 q 的 LCA。如果没有 LCA，就返回 null。</p><p>从根节点 root 开始往下递归遍历……</p><ul><li><p>如果遍历到 p 或 q，比方说 p，则 LCA 要么是当前的 p（q 在 p 的子树中），要么是 p 之上的节点（q 不在 p 的子树中），不可能是 p 之下的节点，不用继续往下走，返回当前的 p。</p></li><li><p>当遍历到 null 节点，空树不存在 p 和 q，没有 LCA，返回 null。</p></li><li><p>当遍历的节点 root 不是 p 或 q 或 null，则递归搜寻 root 的左右子树：</p><ul><li>如果左右子树的递归都有结果，说明 p 和 q 分居 root 的左右子树，返回 root。</li><li>如果只是一个子树递归调用有结果，说明 p 和 q 都在这个子树，返回该子树递归结果。</li><li>如果两个子树递归结果都为 null，说明 p 和 q 都不在这俩子树中，返回 null。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span> || root === p || root === q) <span class="keyword">return</span> root; <span class="comment">// 当遍历越过叶子节点，或者等于p或者q，直接返回</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">left</span>,p,q); <span class="comment">// 递归左子节点，获取返回值</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">right</span>,p,q); <span class="comment">// 递归右子节点，获取返回值</span></span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span>) <span class="keyword">return</span> right; <span class="comment">// 如果左子节点为空，说明p、q不在左子节点上，返回右子节点；或者同时为空，right为null，等于返回null</span></span><br><span class="line">    <span class="keyword">if</span>(right === <span class="literal">null</span>) <span class="keyword">return</span> left; <span class="comment">// 如果右子节点为空，说明p、q不在右子节点上，返回右子节点；或者同时为空，left为null，等于返回null</span></span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 当左右节点都不为空，说明当前节点时p、q的最近公共祖先，返回root</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h2><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 104]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历二叉搜索树，将每一个值推入数组，所得到的为升序数组。然后循环判断最小差值即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">buildArr</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="title function_">buildArr</span>(root.<span class="property">left</span>);</span><br><span class="line">            res.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">            <span class="title function_">buildArr</span>(root.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="title function_">buildArr</span>(root)</span><br><span class="line">    <span class="keyword">let</span> diff = <span class="title class_">Infinity</span>;<span class="comment">// 定义一个极大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; res.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(diff &gt; res[i] - res[i-<span class="number">1</span>])&#123;  <span class="comment">// 判断最小差值</span></span><br><span class="line">            diff = res[i] - res[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在递归中判断极小差值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Infinity</span>; <span class="comment">// 初始定义一个极大值</span></span><br><span class="line">    <span class="keyword">let</span> preNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inOrder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">inOrder</span>(root.<span class="property">left</span>);</span><br><span class="line">        <span class="comment">// 判断当前节点值和前一个节点值的差值与res的大小</span></span><br><span class="line">        <span class="keyword">if</span>(preNode) res = <span class="title class_">Math</span>.<span class="title function_">min</span>(res, root.<span class="property">val</span> - preNode.<span class="property">val</span>);</span><br><span class="line">        preNode = root; <span class="comment">// 记录前一个节点值</span></span><br><span class="line">        <span class="title function_">inOrder</span>(root.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inOrder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先-1"><a href="#236-二叉树的最近公共祖先-1" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul><h3 id="递归-10"><a href="#递归-10" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertIntoBST = <span class="keyword">function</span>(<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123; <span class="comment">// 如果此时为空，说明找到了合适的位置，创建值为val的节点并返回</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> node; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &lt; val) root.<span class="property">right</span> = <span class="title function_">insertIntoBST</span>(root.<span class="property">right</span>, val); <span class="comment">// 如果当前节点的值小于val，则说明val节点应该创建在节点的右侧，进入递归</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="property">val</span> &gt; val) root.<span class="property">left</span> = <span class="title function_">insertIntoBST</span>(root.<span class="property">left</span>, val);<span class="comment">// 如果当前节点的值大于val，则说明val节点应该创建在节点的左侧，进入递归</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-10"><a href="#迭代-10" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertIntoBST = <span class="keyword">function</span>(<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123; <span class="comment">//如果根节点为空，创建一个值为val的节点，直接返回</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> parent = root; <span class="comment">// 记录父节点，每次循环都要记录，方便进行赋值</span></span><br><span class="line">    <span class="keyword">let</span> cur = root; <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123; <span class="comment">// 循环，寻找适合val的位置</span></span><br><span class="line">        parent = cur; <span class="comment">// 每次循环都要记录当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">val</span> &gt; val) cur = cur.<span class="property">left</span>;</span><br><span class="line">        <span class="keyword">else</span> cur = cur.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val); <span class="comment">// 创建一个值为val的节点</span></span><br><span class="line">    <span class="keyword">if</span>(val &gt; parent.<span class="property">val</span>) parent.<span class="property">right</span> = node; <span class="comment">// 决定创建的节点该放在哪里</span></span><br><span class="line">    <span class="keyword">else</span> parent.<span class="property">left</span> = node;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="迭代-11"><a href="#迭代-11" class="headerlink" title="迭代"></a>迭代</h3><p>二叉搜索树是有顺序的，它是有序树，所有 如果 中间节点是 q 和 p 的公共祖先，那么 <strong>中节点的数组 一定是在 [p, q]区间</strong>的。即 中节点 &gt; p &amp;&amp; 中节点 &lt; q 或者 中节点 &gt; q &amp;&amp; 中节点 &lt; p。找到的第一个节点就是p和q的公共祖先节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &lt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &lt; q.<span class="property">val</span>)&#123;</span><br><span class="line">            root = root.<span class="property">right</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="property">val</span> &gt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &gt; q.<span class="property">val</span>)&#123;</span><br><span class="line">            root = root.<span class="property">left</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h2><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [], key = 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h3 id="递归-11"><a href="#递归-11" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span>(<span class="params">root, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取匹配节点的右子树的最小节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">getMin</span> = (<span class="params">node</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(node.<span class="property">left</span>)&#123;</span><br><span class="line">            node = node.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &lt; key)&#123;</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">deleteNode</span>(root.<span class="property">right</span>, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="property">val</span> &gt; key)&#123;</span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">deleteNode</span>(root.<span class="property">left</span>, key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 第一种情况：root只有左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span> === <span class="literal">null</span>) <span class="keyword">return</span> root.<span class="property">left</span>;</span><br><span class="line">        <span class="comment">// 第二种情况： root只有右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span> === <span class="literal">null</span>) <span class="keyword">return</span> root.<span class="property">right</span>;</span><br><span class="line">        <span class="comment">// 第三种情况：左右子树都存在，这时需要将匹配节点替换成右子树中最小的节点，同事删除右子树中最小的节点</span></span><br><span class="line">        <span class="keyword">let</span> min = <span class="title function_">getMin</span>(root.<span class="property">right</span>);</span><br><span class="line">        root.<span class="property">val</span> = min.<span class="property">val</span>;</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">deleteNode</span>(root.<span class="property">right</span>, min.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="669-修剪二叉树"><a href="#669-修剪二叉树" class="headerlink" title="669.修剪二叉树"></a>669.修剪二叉树</h2><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 104]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li><li>树中每个节点的值都是 <strong>唯一</strong> 的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><code>0 &lt;= low &lt;= high &lt;= 104</code></li></ul><h3 id="递归-12"><a href="#递归-12" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trimBST = <span class="keyword">function</span>(<span class="params">root, low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> root; <span class="comment">// 如果节点为空，直接返回节点</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &lt; low)&#123; <span class="comment">// 如果当前节点的值小于最小边界，则将他及其他左子树全部修建，去右子树中寻找合适的节点，并将其返回</span></span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">trimBST</span>(root.<span class="property">right</span>, low, high);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &gt; high)&#123;<span class="comment">// 如果当前节点的值大于最大边界，则将他及其他右子树全部修建，去左子树中寻找合适的节点，并将其返回</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">trimBST</span>(root.<span class="property">left</span>, low, high);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">trimBST</span>(root.<span class="property">left</span>, low, high); <span class="comment">// 拼接左节点</span></span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">trimBST</span>(root.<span class="property">right</span>, low, high); <span class="comment">// 拼接右节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h3 id="递归-13"><a href="#递归-13" class="headerlink" title="递归"></a>递归</h3><p>进行数组划分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="title function_">traversal</span> = (<span class="params">nums, left, right</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((right + left) / <span class="number">2</span>);<span class="comment">// 获取当前数组中间值索引</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]); <span class="comment">// 根据索引创建根节点</span></span><br><span class="line">    node.<span class="property">left</span> = <span class="title function_">traversal</span>(nums, left, mid - <span class="number">1</span>); <span class="comment">// 将数组的划分的左部分进行递归</span></span><br><span class="line">    node.<span class="property">right</span> = <span class="title function_">traversal</span>(nums, mid + <span class="number">1</span>, right); <span class="comment">// 将数组划分的右部分进行递归</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">traversal</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h2><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li><li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul><h3 id="递归-14"><a href="#递归-14" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> convertBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>; <span class="comment">// 记录前一个节点的值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">convert</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">convert</span>(root.<span class="property">right</span>); <span class="comment">// 从右节点开始遍历</span></span><br><span class="line">        root.<span class="property">val</span> += pre; <span class="comment">// 加上前一个节点的值</span></span><br><span class="line">        pre = root.<span class="property">val</span>; <span class="comment">// 记录上一个节点的值</span></span><br><span class="line">        <span class="title function_">convert</span>(root.<span class="property">left</span>); <span class="comment">// 遍历左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">convert</span>(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h3 id="迭代-12"><a href="#迭代-12" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> convertBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>; <span class="comment">// 作用：记录前一个节点的val值</span></span><br><span class="line">    <span class="keyword">let</span> cur = root; <span class="comment">// cur辅助节点，用于进入循环</span></span><br><span class="line">    <span class="keyword">let</span> stack = []; <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">while</span>(cur !== <span class="literal">null</span> || stack.<span class="property">length</span> &gt; <span class="number">0</span>)&#123; <span class="comment">// 循环条件，树不为空或者栈长度大于0</span></span><br><span class="line">        <span class="keyword">while</span>(cur !== <span class="literal">null</span>)&#123; <span class="comment">// 首先不断将当前节点的右节点推入数组</span></span><br><span class="line">            stack.<span class="title function_">push</span>(cur);</span><br><span class="line">            cur = cur.<span class="property">right</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.<span class="title function_">pop</span>(); <span class="comment">// 取出最右的节点</span></span><br><span class="line">        cur.<span class="property">val</span> += pre; <span class="comment">// 与pre进行相加</span></span><br><span class="line">        pre = cur.<span class="property">val</span>; <span class="comment">// pre记录当前节点的值，用于下次相加</span></span><br><span class="line">        cur = cur.<span class="property">left</span>; <span class="comment">// 搜索cur的左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h1 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h1><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="keyword">function</span>(<span class="params">n, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = []; <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">let</span> path =  <span class="comment">// 表示其中的一种可能</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">backtracking</span> = (<span class="params">n, k, startIndex</span>) =&gt; &#123; <span class="comment">// startIndex:防止出现重复的组合</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> === k)&#123; <span class="comment">// 递归终止条件：path的长度等于要求的k长度时结束递归</span></span><br><span class="line">            res.<span class="title function_">push</span>([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt;= n;i++)&#123;</span><br><span class="line">            path.<span class="title function_">push</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="title function_">backtracking</span>(n, k, i+<span class="number">1</span>);  <span class="comment">// 进入递归</span></span><br><span class="line">            path.<span class="title function_">pop</span>(); <span class="comment">// 回溯，撤销处理的节点，进入下次循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝优化</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="keyword">function</span>(<span class="params">n, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">backtracking</span> = (<span class="params">n, k, startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> === k)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当for循环选择的起始位置之后的元素个数已经不足需要的元素个数了，那么就没有必要搜索了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt;= n-(k-path.<span class="property">length</span>)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            path.<span class="title function_">push</span>(i);</span><br><span class="line">            <span class="title function_">backtracking</span>(n, k, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="216-组合总和"><a href="#216-组合总和" class="headerlink" title="216.组合总和|||"></a>216.组合总和|||</h2><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 4, n = 1</span><br><span class="line">输出: []</span><br><span class="line">解释: 不存在有效的组合。</span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum3 = <span class="keyword">function</span>(<span class="params">k, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracking</span> = (<span class="params">k, targetSum, startIndex</span>) =&gt; &#123; </span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> === k)&#123; <span class="comment">// 当path的长度等于规定的长度时返回</span></span><br><span class="line">            <span class="keyword">if</span>(targetSum === <span class="number">0</span>) res.<span class="title function_">push</span>([...path]); <span class="comment">// 当结果值等于0时，推入数组</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line">            path.<span class="title function_">push</span>(i); <span class="comment">// 处理结果</span></span><br><span class="line">            targetSum -= i; <span class="comment">// 总和减1</span></span><br><span class="line">            <span class="title function_">backTracking</span>(k, targetSum, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            targetSum += i; <span class="comment">// 回溯， 撤销处理的节点</span></span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracking</span>(k, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的组合"><a href="#17-电话号码的组合" class="headerlink" title="17.电话号码的组合"></a>17.电话号码的组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCombinations = <span class="keyword">function</span>(<span class="params">digits</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> letterMap = [<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]; <span class="comment">// 讲电话号码对应的字母写进数组，下标从2开始</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">if</span>(digits.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> []; <span class="comment">// 容错，当digits的长度为0也就是空时，返回空数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracking</span> = (<span class="params">n, k, index</span>) =&gt; &#123; <span class="comment">// n表示digits,k表示它的长度，也就是需要循环几次，index表示遍历到哪个数字</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> === k)&#123; <span class="comment">// 当path的长度等于k时返回</span></span><br><span class="line">            res.<span class="title function_">push</span>(path.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一个数字代表的是不同集合，也就是求不同集合之间的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> letterMap[n[index]])&#123;  <span class="comment">// 遍历传进来的字符串对应的字母，index用于控制哪个数字，不然会重复遍历同一个数字</span></span><br><span class="line">            path.<span class="title function_">push</span>(i);</span><br><span class="line">            <span class="title function_">backTracking</span>(n, k, index + <span class="number">1</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>(); <span class="comment">// 回溯，撤销上一个结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracking</span>(digits, digits.<span class="property">length</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39-组合"><a href="#39-组合" class="headerlink" title="39.组合"></a>39.组合</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum = <span class="keyword">function</span>(<span class="params">candidates, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">target, startIndex </span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target === <span class="number">0</span>)</span><br><span class="line">                res.<span class="title function_">push</span>([...path])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt; candidates.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            path.<span class="title function_">push</span>(candidates[i]);</span><br><span class="line">            target -= candidates[i];</span><br><span class="line">            <span class="title function_">backTracing</span>(target, i); <span class="comment">// 因为可以取重复值，所以i不加1</span></span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">            target += candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和"><a href="#40-组合总和" class="headerlink" title="40.组合总和"></a>40.组合总和</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><p>与组合不同的是，每一个组合不能重复，且组合里的值也不能重复。</p><p>关键点：</p><ol><li>要给数组排序</li><li>加一条判断<code>if(i - 1 &gt;= startIndex &amp;&amp; candidates[i-1] === candidates[i])</code>，符合直接continue</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum2 = <span class="keyword">function</span>(<span class="params">candidates, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    candidates = candidates.<span class="title function_">sort</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">target, startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target === <span class="number">0</span>) res.<span class="title function_">push</span>([...path]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt; candidates.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= startIndex &amp;&amp; candidates[i-<span class="number">1</span>] === candidates[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target -= candidates[i];</span><br><span class="line">            path.<span class="title function_">push</span>(candidates[i]);</span><br><span class="line">            <span class="title function_">backTracing</span>(target, i + <span class="number">1</span>);</span><br><span class="line">            target += candidates[i];</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> partition = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isPalindrome</span> = (<span class="params">s, start, end</span>) =&gt; &#123; <span class="comment">// 判断是不是回文字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=start, j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] !== s[j])   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex === s.<span class="property">length</span>)&#123; <span class="comment">//当startIndex等于s.length时，说明已经遍历完一遍了，返回</span></span><br><span class="line">            res.<span class="title function_">push</span>([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt; s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_">isPalindrome</span>(s, startIndex, i)) <span class="keyword">continue</span>; <span class="comment">// 如果不是回文字符串，直接跳过当前循环</span></span><br><span class="line">            path.<span class="title function_">push</span>(s.<span class="title function_">slice</span>(startIndex, i+<span class="number">1</span>)); <span class="comment">// 否则将回文字符串推入数组</span></span><br><span class="line">            <span class="title function_">backTracing</span>(i+<span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="title function_">pop</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        res.<span class="title function_">push</span>([...path]);</span><br><span class="line">        <span class="comment">// 不用写结束条件，当startIndex超过nums.length，不会进入循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="title function_">backTracing</span>(i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="90-子集Ⅱ"><a href="#90-子集Ⅱ" class="headerlink" title="90.子集Ⅱ"></a>90.子集Ⅱ</h2><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为要去重，所以先将数组升序排列</span></span><br><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">let</span> numsArr = nums.<span class="title function_">sort</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        res.<span class="title function_">push</span>([...path]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt; numsArr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 去重，当数组前一个索引和当前索引对应的值相同时，跳过当前循环</span></span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= startIndex &amp;&amp; numsArr[i-<span class="number">1</span>] === numsArr[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="title function_">push</span>(numsArr[i]);</span><br><span class="line">            <span class="title function_">backTracing</span>(i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,6,7,7]</span><br><span class="line">输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,4,3,2,1]</span><br><span class="line">输出：[[4,4]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 15</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findSubsequences = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracking</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> use = []; <span class="comment">// 标记当前层是否有使用过对应的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((path.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path[path.<span class="property">length</span> - <span class="number">1</span>]) || use[nums[i]+<span class="number">100</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            use[nums[i]+<span class="number">100</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">backTracking</span>(i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracking</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> path = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">used</span>) =&gt; &#123; <span class="comment">// 定义used数组，用于判断当前数是否使用过</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> === nums.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123; <span class="comment">// 因为每个数都要遍历到，所以从0开始遍历</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] === <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// 将当前数的索引对应的used置为true，表示使用过</span></span><br><span class="line">            <span class="title function_">backTracing</span>(used);</span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>([]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-全排序Ⅱ"><a href="#47-全排序Ⅱ" class="headerlink" title="47.全排序Ⅱ"></a>47.全排序Ⅱ</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permuteUnique = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> path = [];</span><br><span class="line">    <span class="keyword">let</span> numsArr = nums.<span class="title function_">sort</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">used</span>) =&gt; &#123; <span class="comment">// 定义used数组，用于判断当前数是否使用过</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> === numsArr.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; numsArr.<span class="property">length</span>;i++)&#123; <span class="comment">// 因为每个数都要遍历到，所以从0开始遍历</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] === <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; numsArr[i - <span class="number">1</span>] === numsArr[i] &amp;&amp; used[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            path.<span class="title function_">push</span>(numsArr[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// 将当前数的索引对应的used置为true，表示使用过</span></span><br><span class="line">            <span class="title function_">backTracing</span>(used);</span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>([]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="51-n皇后"><a href="#51-n皇后" class="headerlink" title="51.n皇后"></a>51.n皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[&quot;Q&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> solveNQueens = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="comment">// 判断是否有效</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isVaild</span> = (<span class="params">row,col,chessBoard,n</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同一行不能有</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessBoard[i][col] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在45°不能有</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=row-<span class="number">1</span>,j=col-<span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessBoard[i][j] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在135°不能有</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col + <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessBoard[i][j] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 将chessBoard二维数组转换为字符串数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changeChessBoard</span> = (<span class="params">chessBoard</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> chessBoardRes = [];</span><br><span class="line">        chessBoard.<span class="title function_">forEach</span>(<span class="function"><span class="params">row</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            row.<span class="title function_">forEach</span>(<span class="function"><span class="params">col</span> =&gt;</span> &#123;</span><br><span class="line">                str += col;</span><br><span class="line">            &#125;)</span><br><span class="line">            chessBoardRes.<span class="title function_">push</span>(str);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> chessBoardRes;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 回溯</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">row, chessBoard</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(row === n)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(<span class="title function_">changeChessBoard</span>(chessBoard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>;col &lt; n;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">isVaild</span>(row,col,chessBoard,n))&#123; <span class="comment">// 当前列有效时进入递归</span></span><br><span class="line">                chessBoard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="title function_">backTracing</span>(row+<span class="number">1</span>,chessBoard);</span><br><span class="line">                chessBoard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> chessBoard = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">    <span class="title function_">backTracing</span>(<span class="number">0</span>, chessBoard)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;101023&quot;</span><br><span class="line">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [],path = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params">i</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> len = path.<span class="property">length</span>; <span class="comment">// 获取当前path的长度</span></span><br><span class="line">        <span class="keyword">if</span>(len === <span class="number">4</span> &amp;&amp; i === s.<span class="property">length</span>)&#123; <span class="comment">// 因为path推入的是一个ip字段，判断是否为4，且i此时等于s的长度，说明匹配到了合适的ip地址，将其推入结果数组</span></span><br><span class="line">            res.<span class="title function_">push</span>(path.<span class="title function_">join</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i;j &lt; s.<span class="property">length</span>;j++)&#123; <span class="comment">// i表示起始位置，j表示字符的截取位置</span></span><br><span class="line">            <span class="keyword">let</span> str = s.<span class="title function_">slice</span>(i,j+<span class="number">1</span>); <span class="comment">// 截取字符串</span></span><br><span class="line">            <span class="keyword">if</span>(str.<span class="property">length</span> &gt; <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] === <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前字符串是0开头，且长度大于1，跳出当前循环，如01 </span></span><br><span class="line">            <span class="keyword">if</span>(+str &gt; <span class="number">255</span> || str.<span class="property">length</span> &gt; <span class="number">3</span>) <span class="keyword">break</span>; <span class="comment">// 如果str大于255或长度大于3，跳出当前循环</span></span><br><span class="line">            path.<span class="title function_">push</span>(str);</span><br><span class="line">            <span class="title function_">backTracing</span>(j+<span class="number">1</span>); <span class="comment">// 进入递归,让j+1，指向字符串的下一个</span></span><br><span class="line">            path.<span class="title function_">pop</span>();     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> solveSudoku = <span class="keyword">function</span>(<span class="params">board</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断数独是否有效</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isValid</span> = (<span class="params">row, col, val, board</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> len = board.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i] === val) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] === val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> startRow = <span class="title class_">Math</span>.<span class="title function_">floor</span>(row / <span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">let</span> startCol = <span class="title class_">Math</span>.<span class="title function_">floor</span>(col / <span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startRow;i &lt; startRow+<span class="number">3</span>;i++)&#123; <span class="comment">// 判断数组3×3格是否有效</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = startCol;j &lt; startCol + <span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] === val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracing</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; board.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; board[i].<span class="property">length</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] === <span class="string">&#x27;.&#x27;</span>)&#123; <span class="comment">// 仅当当前格子不为.时进入递归</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> val = <span class="number">1</span>;val &lt;= <span class="number">9</span>;val++)&#123; <span class="comment">// 循环可输入数</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="title function_">isValid</span>(i, j, <span class="string">`<span class="subst">$&#123;val&#125;</span>`</span>, board))&#123; <span class="comment">// 当前数有效时，将其赋在对应的索引上</span></span><br><span class="line">                            board[i][j] = <span class="string">`<span class="subst">$&#123;val&#125;</span>`</span>; </span><br><span class="line">                            <span class="keyword">if</span>(<span class="title function_">backTracing</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 都遍历完说明没有匹配的数字，返回false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>();</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>将g小孩胃口，s饼干尺寸进行升序排序，从尾开始遍历胃口，用最大尺寸的饼干满足最大胃口的小孩，直到胃口遍历完。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findContentChildren = <span class="keyword">function</span>(<span class="params">g, s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    s.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    g.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> m = g.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = m-<span class="number">1</span>,j =n -<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123; <span class="comment">// 遍历胃口</span></span><br><span class="line">        <span class="keyword">if</span>(s[j] &gt;= g[i] &amp;&amp; j &gt;= <span class="number">0</span>)&#123; <span class="comment">// 跟饼干尺寸比大小</span></span><br><span class="line">            index++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.斐波那契数列</h2><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [<span class="number">0</span>,<span class="number">1</span>]; <span class="comment">// 记录前两个值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123; <span class="comment">// 从小数开始，遍历到n</span></span><br><span class="line">        res[i] = res[i-<span class="number">1</span>] + res[i-<span class="number">2</span>]; <span class="comment">// 修改n对应下标的数，为前两个数相加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改良，只依赖前两个数据，所以只需要维护前两个数据就可以。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">let</span> res = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> sum ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        sum = res[<span class="number">0</span>] + res[<span class="number">1</span>]; <span class="comment">// 维护两个值即可</span></span><br><span class="line">        res[<span class="number">0</span>] = res[<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">1</span>] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>与斐波那契数列一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">let</span> pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> pre2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        sum = pre1 + pre2;</span><br><span class="line">        pre1 = pre2;</span><br><span class="line">        pre2 = sum;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指offer-42-连续子数组的最大和"><a href="#剑指offer-42-连续子数组的最大和" class="headerlink" title="剑指offer 42.连续子数组的最大和"></a>剑指offer 42.连续子数组的最大和</h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><h3 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h3><p><img src="https://pic.leetcode-cn.com/8fec91e89a69d8695be2974de14b74905fcd60393921492bbe0338b0a628fd9a-Picture1.png" alt="Picture1.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        nums[i] += <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i-<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.比特位计数</h1><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：[0,1,1]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：[0,1,1,2,1,2]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></table></figure><h3 id="使用Brian-Kernighan-（比特计算）算法"><a href="#使用Brian-Kernighan-（比特计算）算法" class="headerlink" title="使用Brian Kernighan （比特计算）算法"></a>使用Brian Kernighan （比特计算）算法</h3><p>使用<strong><em>x &#x3D; x&amp;(x-1</em>)<strong>可以将x的二进制数减少一个1，使用循环</strong>将计数变量递增</strong>计算1的个数即可。</p><p>解题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        arr[i] = <span class="title function_">counts</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">counts</span>(<span class="params">i</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        i = i &amp; (i-<span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.找到所有数组中消失的数字</h1><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">输出：[5,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p>思路：我的思路是使用includes从1到n(数组长度)进行判断，如果不包含，则直接数字i存入新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDisappearedNumbers = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> newNums = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.<span class="title function_">includes</span>(i))&#123;</span><br><span class="line">            newNums.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方题解：遍历数组，使用<strong>范围之外的数字</strong>来表示存在在数组nums中的数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDisappearedNumbers = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = (num - <span class="number">1</span>) % n; <span class="comment">//这里的n-1代表在序列数组中num本来应该所在的序号，因为num的范围是从1开始的。%n是为了避免碰到重复的数字，num已经加过n了。这样到最后，只有没有出现的数字所在的序号不会被加n。</span></span><br><span class="line">        nums[x] += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="comment">//nums.entries()是生成nums的键值队，[0,]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [i, num] <span class="keyword">of</span> nums.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">            ret.<span class="title function_">push</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">链接：<span class="attr">https</span>:<span class="comment">//leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/solutions/601946/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例 </span><br><span class="line">for (const num of nums) &#123;</span><br><span class="line">    const x = (num - 1) % n;</span><br><span class="line">    nums[x] += n;</span><br><span class="line">&#125;</span><br><span class="line">原数组 4,3,2,7,8,2,3,1     </span><br><span class="line">第一次交换  num = 4 x=34,3,2,15,8,2,3,1      </span><br><span class="line">第二次交换  num = 3x=24,3,10,15,8,2,3,1     </span><br><span class="line">第三次交换  num = 10 x=14,11,10,15,8,2,3,1   </span><br><span class="line">第四次交换  num = 15x=64,11,10,15,8,2,11,1          </span><br><span class="line">第五次交换  num = 8x=712,11,10,15,8,2,11,9 </span><br><span class="line">第六次交换  num = 2x=112,19,10,15,8,2,11,9 </span><br><span class="line">第七次交换  num = 11x=212,19,18,15,8,2,11,9</span><br><span class="line">第八次交换  num = 10 x=1 12,27,18,15,8,2,11,9</span><br><span class="line">由此可见，8和2没有变化，即它们所在的序列加一就是没有出现的数字</span><br></pre></td></tr></table></figure><hr><h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h1><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 1, y = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 3, y = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p> 我的解法</p><p>使用blob函数分别将x，y转换成二进制，并将它传给数组返回。然后对它们for循环进行比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingDistance = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> X = <span class="title function_">blob</span>(x);</span><br><span class="line">    <span class="keyword">let</span> Y = <span class="title function_">blob</span>(y);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,j = <span class="number">0</span>;<span class="comment">//j计算x和y二进制位数不同的个数</span></span><br><span class="line">    <span class="keyword">let</span> length = X.<span class="property">length</span> &gt;= Y.<span class="property">length</span> ? X.<span class="property">length</span> : Y.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(X[i]!=Y[i])</span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">blob</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">32</span>);</span><br><span class="line">    arr.<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        i = x % <span class="number">2</span>;</span><br><span class="line">        arr[j++] = i;</span><br><span class="line">        x = <span class="built_in">parseInt</span>(x/<span class="number">2</span>);<span class="comment">//js的Number不分整型和浮点型，所以要使用parseInt将/2的结果转为整型。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方</p><ul><li><strong>移位实现位计数</strong></li></ul><p>​将x和y进行异或，<strong>相同为0，不同为1</strong>，这样异或的结果s中为1的便是x和y二进制中不同的地方。然后让最低位和1进行与运算，相同则加一，不同加0，随后让s右移一位，再进行与运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingDistance = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> s = x ^ y;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        i = s &amp; <span class="number">1</span>;</span><br><span class="line">        count+=i;</span><br><span class="line">        s = s&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Brian Kernighan （比特计算）算法</strong></li></ul><p>​s &#x3D; x ^ y。x和y异或后，所得的s为一个<strong>包含1和0的二进制数</strong>，如10001101，这样需要循环8次才能获得结果，可以使用<strong>Brian Kernighan （比特计算）算法</strong>计算s中1的个数，即使用<strong>x&amp;(x-1)<strong>，每运行一次，s中的1就会减少1个。该算法会</strong>删去s中最右侧的1</strong>，最终循环的次数即为s二进制表示中1的数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingDistance = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">s = x ^ y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;s &gt; <span class="number">0</span>;i++)&#123;</span><br><span class="line">        s = s &amp; (s-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="78-子集-1"><a href="#78-子集-1" class="headerlink" title="78.子集"></a>78.子集</h1><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><h1 id="20-有效的括号-1"><a href="#20-有效的括号-1" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>题解：使用栈进行解决，将右括号存储在数组中，然后将字符串一一入栈，如果是左括号则入栈，如果是右括号进行判断，如果跟出栈的符号能对应，则继续循环，否则return false。到最后，如果栈为空，则return true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];<span class="comment">//栈</span></span><br><span class="line">    s = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//将字符串分割成数组</span></span><br><span class="line">    <span class="keyword">let</span> right = [<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;]&#x27;</span>];<span class="comment">//将右阔靠存在right数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!right.<span class="title function_">includes</span>(s[i]))&#123;<span class="comment">//如果不是右括号则推入栈中</span></span><br><span class="line">            stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是则进行判断</span></span><br><span class="line">            <span class="keyword">switch</span>(s[i])&#123;<span class="comment">//跟栈顶出栈的元素进行比较，如果能匹配上，则继续循环，不能就return false</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;&#125;&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!=<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.<span class="property">length</span>==<span class="number">0</span>)&#123;<span class="comment">//最后判断栈的长度，为0则说明全是有效括号，return true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//否则，return false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>我的解法：暴力解法，<strong>利用set去重</strong>获取nums中的唯一值赋给新数组newNums。然后在<strong>深拷贝</strong>一个新的数组newNum。循环nums，如果nums中的值等于newNum中的值，则newNums加上自己。循环完后再循环newNums，如果它减去newNum中的对应的值再除去newNum对应的值大于n&#x2F;2的话则返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> time = nums.<span class="property">length</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> newNums = [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums)];<span class="comment">//去重，获得新数组</span></span><br><span class="line">    <span class="keyword">let</span> newNum = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newNums));<span class="comment">//深拷贝一个新数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; newNums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==newNum[j])<span class="comment">//如果值相等</span></span><br><span class="line">                newNums[j]+=newNum[j];<span class="comment">//newNums加上自身</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; newNums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((newNums[i]-newNum[i])/newNum[i]&gt;time)&#123;<span class="comment">//如果减去自身除以自身大于time则返回</span></span><br><span class="line">            <span class="keyword">return</span> newNum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h2><p>用哈希表统计数组元素中每个元素出现的次数，返回所有统计次数超过n&#x2F;2的元素。元素作为哈希表的键，出现的次数作为哈希表的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();<span class="comment">//创建哈希表</span></span><br><span class="line">    <span class="keyword">let</span> time = nums.<span class="property">length</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(nums[i]))&#123;<span class="comment">//如果map有nums[i],则让次数加一</span></span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],map.<span class="title function_">get</span>(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有，则添加</span></span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>())&#123;<span class="comment">//使用for ... of遍历map的key</span></span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(key)&gt;time)&#123;<span class="comment">//如果key对应的值大于time则返回</span></span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h2><p>记录第一个士兵为winner&#x3D;nums[i]，然后设置count计数器为0。遍历循环数组，当与winner相同时，count++，不相同，count–，当count为0时，nums[i]重新赋值给winner。这样遍历结束后，winner就是所求的数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> winner = nums[<span class="number">0</span>];<span class="comment">//创建士兵</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;<span class="comment">//创建计数器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(winner == nums[i])&#123;<span class="comment">//当nums[i]与士兵相同时count++</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;<span class="comment">//减到后面count为0时，winner重新赋值</span></span><br><span class="line">            winner = nums[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//不同时,count--</span></span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> winner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>“同归于尽消杀法” ：</p><p>由于多数超过50%, 比如100个数，那么多数至少51个，剩下少数是49个。</p><ol><li>遍历数组</li><li>第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地，此时领主 winner 就是这个阵营的人，现存兵力 count &#x3D; 1。</li><li>如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地，领主不变，winner 依然是当前这个士兵所属阵营，现存兵力 count 加一；</li><li>如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽。 此时前方阵营兵力-1, 即使双方都死光，这块高地的旗帜 winner 不变，没有可以去换上自己的新旗帜。</li><li>当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主，winner 变成这个士兵所属阵营的旗帜，现存兵力 count ++。</li><li>就这样各路军阀一直厮杀以一敌一同归于尽的方式下去，直到少数阵营都死光，剩下几个必然属于多数阵营的，winner 是多数阵营。</li></ol><p>（多数阵营 51个，少数阵营只有49个，死剩下的2个就是多数阵营的人）</p><h1 id="229-多数元素"><a href="#229-多数元素" class="headerlink" title="229.多数元素||"></a>229.多数元素||</h1><h2 id="暴力解法-2"><a href="#暴力解法-2" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> time = nums.<span class="property">length</span> / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Element</span> = [];</span><br><span class="line">    <span class="keyword">let</span> newNums = [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums)];</span><br><span class="line">    <span class="keyword">let</span> newNum = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newNums));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; newNums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==newNum[j] &amp;&amp; nums[i]!=<span class="number">0</span>)</span><br><span class="line">                newNums[j]+=newNum[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==newNum[j] &amp;&amp; nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                newNums[j]+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; newNums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newNum[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                formula = (newNums[i]-newNum[i])/<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                formula = (newNums[i]-newNum[i])/newNum[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(formula&gt;time)&#123;</span><br><span class="line">                <span class="title class_">Element</span>.<span class="title function_">push</span>(newNum[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Element</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h2><p>用哈希表统计数组元素中每个元素出现的次数，返回所有统计次数超过n&#x2F;3的元素。元素作为哈希表的键，出现的次数作为哈希表的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> time = nums.<span class="property">length</span> / <span class="number">3</span>;<span class="comment">//获取出现次数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Element</span> = [];</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();<span class="comment">//创建map字典，map键值一一对应</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(nums[i]))&#123;<span class="comment">//如果map有nums[i],则让次数加一</span></span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],map.<span class="title function_">get</span>(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有，则添加</span></span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> o <span class="keyword">of</span> map.<span class="title function_">keys</span>())&#123;<span class="comment">//使用for ... of遍历map的key</span></span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(o)&gt;time)&#123;<span class="comment">//如果key对应的值大于time则将其加入数组</span></span><br><span class="line">            <span class="title class_">Element</span>.<span class="title function_">push</span>(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Element</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,2,1,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>题目要求只是用常量额外空间，所以不能使用哈希表，使用哈希表则空间复杂度为O(n)，可以使用异或运算。</p><p>​异或运算两数相同为0，不同为1。拓展开来，两个不同的数相异或，得到另一个数，当第二次遇到其中一个数时则会还原成另一个数。这用到了异或的交换律和结合律。<em>a</em>⊕<em>b</em>⊕<em>a</em>&#x3D;<em>b</em>⊕<em>a</em>⊕<em>a</em>&#x3D;<em>b</em>⊕(<em>a</em>⊕<em>a</em>)&#x3D;<em>b</em>⊕0&#x3D;<em>b</em>。</p><p><img src="https://assets.leetcode-cn.com/solution-static/136/3.PNG" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> single = nums[<span class="number">0</span>];<span class="comment">//先获取第一个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;<span class="comment">//i从1开始遍历</span></span><br><span class="line">        single ^= nums[i];<span class="comment">//不断与所有数进行异或，相同为0不同为1，剩到最后的数为只出现一次的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希表（不考虑空间复杂度）"><a href="#哈希表（不考虑空间复杂度）" class="headerlink" title="哈希表（不考虑空间复杂度）"></a>哈希表（不考虑空间复杂度）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(nums[i]))&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],map.<span class="title function_">get</span>(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(key) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须<strong>在不复制数组</strong>的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>创建一个count变量为0作为数组下标，for …of遍历数组，当数组的值不为0的时候，将当前数组的值赋给以count作为下标的数组，令count++进入下一次循环。随后count的值一定为数组不为0的数字的长度。for循环nums.length-count次，给数组末尾补0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;<span class="comment">//for...of中的i是数组的value值</span></span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;<span class="comment">//此方法是索引从0开始，让数组的不为0的值覆盖为0的值</span></span><br><span class="line">            nums[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;count&lt;nums.<span class="property">length</span>;count++)&#123;</span><br><span class="line">        nums[count] = <span class="number">0</span>;<span class="comment">//想数组末尾补0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>两层循环遍历，当遍历的值为0时，让当前值与后面的值进行交换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">            nums[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;count&lt;nums.<span class="property">length</span>;count++)&#123;</span><br><span class="line">        nums[count] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h1><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="title class_">Math</span>.<span class="title function_">floor</span>((n + <span class="number">1</span>) / <span class="number">2</span>); ++j) &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="206-反转链表-1"><a href="#206-反转链表-1" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="迭代-13"><a href="#迭代-13" class="headerlink" title="迭代"></a>迭代</h2><p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3.</p><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">        <span class="keyword">const</span> next = curr.<span class="property">next</span>;<span class="comment">//储存当前节点的下一个节点</span></span><br><span class="line">        curr.<span class="property">next</span> = prev;<span class="comment">//让当前节点的next指向prev</span></span><br><span class="line">        prev = curr;<span class="comment">//prev等于当前节点，进入下次循环</span></span><br><span class="line">        curr = next;<span class="comment">//curr赋值为刚刚暂存的next值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h2 id="数组双指针"><a href="#数组双指针" class="headerlink" title="数组双指针"></a>数组双指针</h2><p>将链表的值从头节点开始一一存进数组，然后用双指针从头和末尾去遍历数组进行比对。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [];</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(head.<span class="property">val</span>);</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,j = arr.<span class="property">length</span>-<span class="number">1</span>;i&lt;arr.<span class="property">length</span>,j&gt;<span class="number">0</span>;i++,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != arr[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归-15"><a href="#递归-15" class="headerlink" title="递归"></a>递归</h2><p>将head用全局变量指针存储，然后创建递归函数，<strong>递归会为每一次递归的值创建一个执行上下文栈保留当前状态</strong>，当递归到链表的最后会从后往前回退，然后利用这个特性跟全局变量指针进行对比，每一次都让指针指向下一个节点。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> frontPointer ;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recursivelyCheck</span> (<span class="attr">current</span>:<span class="title class_">ListNode</span> | <span class="literal">null</span>):<span class="built_in">boolean</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current)&#123;<span class="comment">//判断当前节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_">recursivelyCheck</span>(current.<span class="property">next</span>)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//递归会一直执行下去，并将变量当前状态存储在执行上下文栈中，直到链表的末尾后函数返回true,!true不执行所以执行下面的语句。</span></span><br><span class="line">        <span class="keyword">if</span>(frontPointer.<span class="property">val</span> != current.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//将全局指针保存的值跟栈返回的状态的值进行对比，如果不同，则会返回false，上一条if语句就会执行，一直返回fals直到执行上下文栈为空</span></span><br><span class="line">        frontPointer = frontPointer.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    frontPointer = head;<span class="comment">//将头节点用全局变量存储</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">recursivelyCheck</span>(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快慢指针-2"><a href="#快慢指针-2" class="headerlink" title="快慢指针"></a>快慢指针</h2><ol><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否回文。</li><li>恢复链表。</li><li>返回结果。</li></ol><p>使用<strong>快慢指针</strong>在一次遍历中找到：<strong>慢指针一次走一步，快指针一次走两步</strong>，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="title function_">reverseList</span> = (<span class="params">head</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextTemp = curr.<span class="property">next</span>;</span><br><span class="line">        curr.<span class="property">next</span> = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">endOfFirstHalf</span>  (<span class="attr">head</span>:<span class="title class_">ListNode</span> | <span class="literal">null</span>):<span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast.<span class="property">next</span> != <span class="literal">null</span> &amp;&amp; fast.<span class="property">next</span>.<span class="property">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = head;</span><br><span class="line">    <span class="keyword">let</span> afterHalf = <span class="title function_">endOfFirstHalf</span>(head);</span><br><span class="line">    <span class="keyword">let</span> reverAfter = <span class="title function_">reverseList</span>(afterHalf);</span><br><span class="line">    <span class="keyword">while</span>(reverAfter!=<span class="literal">null</span> &amp;&amp; left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.<span class="property">val</span> !== reverAfter.<span class="property">val</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left = left.<span class="property">next</span>;</span><br><span class="line">        reverAfter = reverAfter.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h2 id="迭代-14"><a href="#迭代-14" class="headerlink" title="迭代"></a>迭代</h2><p>首先，我们设定一个哨兵节点 <code>prehead</code> ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 <code>prev </code>指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：<strong>如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作</strong>。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p><p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTwoLists</span>(<span class="params">list1: ListNode | <span class="literal">null</span>, list2: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Link</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="title class_">Link</span>;</span><br><span class="line">    <span class="keyword">while</span>(list1!== <span class="literal">null</span> &amp;&amp; list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.<span class="property">val</span> &lt;= list2.<span class="property">val</span>)&#123;</span><br><span class="line">            prev.<span class="property">next</span> = list1;</span><br><span class="line">            list1 = list1.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev.<span class="property">next</span> = list2;</span><br><span class="line">            list2 = list2.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev.<span class="property">next</span> = list1 === <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Link</span>.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>遍历链表，将链表的每一个节点存入哈希表，最开始判断哈希表中是否有该节点，有的话说明是循环链表，直接返回true。如果循环完哈希表中的值都为1，说明不是循环链表，返回false。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">get</span>(head))&#123;<span class="comment">//先判断哈希表中是否含有该节点，有的话说明是循环链表返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.<span class="title function_">set</span>(head,<span class="number">1</span>);<span class="comment">//没有该节点往哈希表中添加该节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//循环结束，直到最后都没有返回true说明不是循环链表，返回false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快慢指针-3"><a href="#快慢指针-3" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>「Floyd 判圈算法」（又称龟兔赛跑算法），假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。<strong>慢指针每次只移动一步，而快指针每次移动两步</strong>。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>将fast设置为head.next，将slow设置为head是为了能进入while循环，因为循环条件是<strong>slow!&#x3D;fast</strong>，如果他们相等，则无法进入循环。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> fast = head.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast === <span class="literal">null</span> || fast.<span class="property">next</span> === <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142.环形链表Ⅱ"></a>142.环形链表Ⅱ</h1><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>因为set集合不允许重复，所以遍历链表，将每一个节点存入集合，当集合中存在节点说明是循环链表，返回。如果不是，则while循环结束，返回null。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">detectCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.<span class="title function_">has</span>(head))&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.<span class="title function_">add</span>(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快慢指针-4"><a href="#快慢指针-4" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">detectCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast !== <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (fast.<span class="property">next</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast === slow) &#123;</span><br><span class="line">            <span class="keyword">let</span> ptr = head;</span><br><span class="line">            <span class="keyword">while</span> (ptr !== slow) &#123;</span><br><span class="line">                ptr = ptr.<span class="property">next</span>;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><h2 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h2><p>set集合不允许有重复的值，所以可以先将headA的所有节点存入set集合，然后再循环headB判断，如果有相同的说明他们是相交的起始节点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getIntersectionNode</span>(<span class="params">headA: ListNode | <span class="literal">null</span>, headB: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">while</span>(headA != <span class="literal">null</span>)&#123;</span><br><span class="line">        set.<span class="title function_">add</span>(headA);</span><br><span class="line">        headA = headA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headB != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.<span class="title function_">has</span>(headB))&#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针-3"><a href="#双指针-3" class="headerlink" title="双指针"></a>双指针</h2><p>使用双指针的方法，可以将空间复杂度降至 O(1))。</p><p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><p>当链表 headA 和 headB 都不为空时，创建两个指针 pA和 pB，初始时分别指向两个链表的头节点 headA和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><p>每步操作需要同时更新指针 pA 和 pB。</p><p>如果指针 pA 不为空，则将指针 pA移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p><p>如果指针 pA为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p><p>当指针 pA和 pB指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getIntersectionNode</span>(<span class="params">headA: ListNode | <span class="literal">null</span>, headB: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(headA === <span class="literal">null</span> || headB === <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable constant_">PA</span> = headA,<span class="variable constant_">PB</span> = headB;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable constant_">PA</span> != <span class="variable constant_">PB</span>)&#123;</span><br><span class="line">        <span class="variable constant_">PA</span> = <span class="variable constant_">PA</span> ===<span class="literal">null</span> ? headB : <span class="variable constant_">PA</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="variable constant_">PB</span> = <span class="variable constant_">PB</span> ===<span class="literal">null</span> ? headA : <span class="variable constant_">PB</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">PA</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="617-合并二叉树-1"><a href="#617-合并二叉树-1" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1], root2 = [1,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure><h2 id="递归-16"><a href="#递归-16" class="headerlink" title="递归"></a>递归</h2><ol><li>root1为null，root2不为null，返回root2</li><li>root2为null，root1不为null，返回root1</li><li>创建新的树，将root1和root2的val值进行相加，节点的left和right为root1和root2节点的left和right的val值相加（即进入递归）</li><li>最后返回树</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTrees</span>(<span class="params">root1: TreeNode | <span class="literal">null</span>, root2: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;</span><br><span class="line">    <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.<span class="property">val</span>+root2.<span class="property">val</span>);</span><br><span class="line">    t.<span class="property">left</span> = <span class="title function_">mergeTrees</span>(root1.<span class="property">left</span>,root2.<span class="property">left</span>);</span><br><span class="line">    t.<span class="property">right</span> = <span class="title function_">mergeTrees</span>(root1.<span class="property">right</span>,root2.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-15"><a href="#迭代-15" class="headerlink" title="迭代"></a>迭代</h2><h1 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226.反转二叉树"></a>226.反转二叉树</h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="递归-17"><a href="#递归-17" class="headerlink" title="递归"></a>递归</h2><p>采用先序遍历，先判断当前二叉树是否是null，是的话就返回null，遍历交换当前节点的左右节点，然后再递归，将左右节点分别传入函数，最后返回root二叉树。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> left  = root.<span class="property">left</span>;<span class="comment">//用变量获取左右节点</span></span><br><span class="line">    <span class="keyword">let</span> right = root.<span class="property">right</span>;</span><br><span class="line">    root.<span class="property">left</span> = right;<span class="comment">//交换左右节点</span></span><br><span class="line">    root.<span class="property">right</span> = left;</span><br><span class="line">    <span class="title function_">invertTree</span>(root.<span class="property">left</span>);<span class="comment">//将左右节点传入函数进行递归交换</span></span><br><span class="line">    <span class="title function_">invertTree</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-16"><a href="#迭代-16" class="headerlink" title="迭代"></a>迭代</h2><p>采用栈存储当前节点，循环条件是栈的长度不为0。然后定义变量存储出栈的值，判断变量是否为null，是的话跳过本次循环，不是则交换左右节点。将左右节点再推入栈中,直到栈为空。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    stack.<span class="title function_">push</span>(root);<span class="comment">//将根节点存储栈中</span></span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> t = stack.<span class="title function_">pop</span>();<span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果t为空，则跳过本次循环，不交换</span></span><br><span class="line">        <span class="keyword">let</span> left = t.<span class="property">left</span>;<span class="comment">//分别用变量存储左右节点</span></span><br><span class="line">        <span class="keyword">let</span> right = t.<span class="property">right</span>;</span><br><span class="line">        t.<span class="property">left</span> = right;<span class="comment">//将t的左右节点进行交换</span></span><br><span class="line">        t.<span class="property">right</span> = left;</span><br><span class="line">        stack.<span class="title function_">push</span>(t.<span class="property">left</span>);<span class="comment">//将交换后的左右节点再推入栈中，进入循环</span></span><br><span class="line">        stack.<span class="title function_">push</span>(t.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="94-二叉树的中序遍历-1"><a href="#94-二叉树的中序遍历-1" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h1><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h2 id="递归-18"><a href="#递归-18" class="headerlink" title="递归"></a>递归</h2><p>中序遍历，左子树——根节点——右子树，访问左子树和右子树的时候同样可以以这种方式遍历。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">t</span>:<span class="built_in">number</span>[] = [];</span><br><span class="line">    <span class="comment">//递归遍历函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root:TreeNode</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="comment">//递归结束条件,节点为空，返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">inorder</span>(root.<span class="property">left</span>);<span class="comment">//先遍历左节点,所有的状态暂存栈中</span></span><br><span class="line">        t.<span class="title function_">push</span>(root.<span class="property">val</span>);<span class="comment">//左节点为空后,一一将值推入数组</span></span><br><span class="line">        <span class="title function_">inorder</span>(root.<span class="property">right</span>);<span class="comment">//遍历右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-17"><a href="#迭代-17" class="headerlink" title="迭代"></a>迭代</h2><p>先一次性将树的左子树的左节点全都推入栈中，随后取出栈顶元素，将其推入数组，然后将当前节点赋值为节点的右孩子，如果右孩子为空，但栈长度仍大于0，进入循环。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">t1</span>:<span class="title class_">TreeNode</span>[] = [],<span class="attr">t2</span>:<span class="built_in">number</span>[] = [];</span><br><span class="line">    <span class="keyword">while</span>(t1.<span class="property">length</span> &gt; <span class="number">0</span> || root)&#123;<span class="comment">//循环条件：数组的长度大于0或者root不为null</span></span><br><span class="line">        <span class="keyword">while</span>(root)&#123;<span class="comment">//先把树的左子树的左节点全都推入栈</span></span><br><span class="line">            t1.<span class="title function_">push</span>(root);</span><br><span class="line">            root = root.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = t1.<span class="title function_">pop</span>();<span class="comment">//栈顶元素出栈</span></span><br><span class="line">        t2.<span class="title function_">push</span>(root.<span class="property">val</span>);<span class="comment">//将值推入数组</span></span><br><span class="line">        root = root.<span class="property">right</span>;<span class="comment">//root赋值为它的右孩子，若右孩子不为空，则会在下一次循环推入栈中，为空，则会跳过root循环，下一个栈顶元素出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="98-验证二叉搜索树-1"><a href="#98-验证二叉搜索树-1" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h1><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="递归-19"><a href="#递归-19" class="headerlink" title="递归"></a>递归</h2><p>设置递归函数，传递三个参数，判断的节点，节点的下界，节点的上界，然后依次递归，如果只单纯比较把节点的左节点和右节点和节点进行比较，那么会出现左右子树中存在值比当前节点小或大的情况，所以<strong>比较的同时要把当前节点的上下界一起传递</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isValidBST</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isTrue = (<span class="attr">root</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>,up,lower):<span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &gt;= up || root.<span class="property">val</span> &lt;= lower)   <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果当前节点大于等于上届，或者小于等于下界，说明不在范围区间内，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">isTrue</span>(root.<span class="property">left</span>,root.<span class="property">val</span>,lower) &amp;&amp; <span class="title function_">isTrue</span>(root.<span class="property">right</span>,up,root.<span class="property">val</span>);<span class="comment">//左节点要比当前节点要小，所以上界传当前节点值，下界为Infinity，右节点要比当前节点大，所以下界传当前节点的值，上界为Infinity</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isTrue</span>(root,<span class="title class_">Infinity</span>,-<span class="title class_">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-18"><a href="#迭代-18" class="headerlink" title="迭代"></a>迭代</h2><p>将节点的所有左节点推入栈，然后出栈顶元素，将栈顶元素的值和定义的最小值比较，如果小的话说明不是二叉搜索树，返回false，大则将节点的值赋给最小值，节点的右节点赋给root。在循环结束后，说明遍历完，返回true。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isValidBST</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> inorder = -<span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span> &gt; <span class="number">0</span> || root)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(root);</span><br><span class="line">            root = root.<span class="property">left</span>;<span class="comment">//将节点的所有左节点入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="title function_">pop</span>();<span class="comment">//出栈顶元素，即最左边的元素</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &lt;= inorder) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果节点的值比定义的最小值小，说明不符合条件按</span></span><br><span class="line">        inorder = root.<span class="property">val</span>;<span class="comment">//大的话进行赋值，进入下次循环</span></span><br><span class="line">        root = root.<span class="property">right</span>;<span class="comment">//节点赋值为右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="102-二叉树的层序遍历-1"><a href="#102-二叉树的层序遍历-1" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h1><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h1 id="迭代-19"><a href="#迭代-19" class="headerlink" title="迭代"></a>迭代</h1><p>将节点存入队列，遵循先进先出的原则进行层序遍历。因为需要把每一层的节点单独存为一个数组，所以在循环的时候获取队列的长度，一次性处理一层的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;<span class="comment">//如果节点为空，直接返回空队列</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">push</span>(root);<span class="comment">//将节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span> !=  <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n = queue.<span class="property">length</span>;<span class="comment">//获取当前节点的长度，也就是这一层的节点个数</span></span><br><span class="line">        <span class="keyword">let</span> q = [];<span class="comment">//存放这一层的节点的数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>(); <span class="comment">//出队           </span></span><br><span class="line">            q.<span class="title function_">push</span>(node.<span class="property">val</span>);<span class="comment">//将节点的值推入数组</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);<span class="comment">//如果节点有左节点，将它推入数组</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);<span class="comment">//如果节点有右节点，将它推入数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="title function_">push</span>(q);<span class="comment">//将这一层的节点值的数组推入节点数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h2 id="递归-20"><a href="#递归-20" class="headerlink" title="递归"></a>递归</h2><p>使用回溯算法进行解题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subsets</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">    <span class="keyword">let</span> path = [];<span class="comment">//每一种可能的结果</span></span><br><span class="line">    <span class="keyword">let</span> result = [];<span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracking</span> = (<span class="params">startIndex</span>)=&gt;&#123;</span><br><span class="line">        result.<span class="title function_">push</span>([...path]);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= nums.<span class="property">length</span>)<span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = startIndex;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            path.<span class="title function_">push</span>(nums[i]);<span class="comment">//将nums中的值推入数组</span></span><br><span class="line">            <span class="title function_">backTracking</span>(i+<span class="number">1</span>);<span class="comment">//令i+1进入递归</span></span><br><span class="line">            path.<span class="title function_">pop</span>();<span class="comment">//撤销结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracking</span>(<span class="number">0</span>);<span class="comment">//传入索引最小的值0进入递归</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/subsets/solutions/850474/dai-ma-sui-xiang-lu-78-zi-ji-hui-su-sou-6yfk6/">78. 子集 - 力扣（Leetcode）</a></p><h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h2 id="递归-21"><a href="#递归-21" class="headerlink" title="递归"></a>递归</h2><p>假定p是树T中的一个节点，那么p的深度就是节点p的祖先的个数，不包括p本身。这<strong>等价于p到根节点有多少条边</strong>。这种定义表明，树的根节点的深度为0.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">depth</span> = (<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> L = <span class="title function_">depth</span>(root.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">let</span> R = <span class="title function_">depth</span>(root.<span class="property">right</span>);</span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans,L+R+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(L,R)+<span class="number">1</span>;<span class="comment">//当前节点较于父节点的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">depth</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75.颜色分类"></a>75.颜色分类</h1><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h2 id="单指针"><a href="#单指针" class="headerlink" title="单指针"></a>单指针</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[ptr];</span><br><span class="line">            nums[ptr] = temp;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[ptr];</span><br><span class="line">            nums[ptr] = temp;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li></ul><h2 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h2><p>初始化的时候定义一个栈和辅助栈，初始存放Infinity，然后入栈时，普通栈正常入栈，辅助栈则是存放辅助栈栈顶和入栈元素中较小的那个值。出栈的时候，普通栈和辅助栈一起出栈，这样普通栈对应的对小值，在辅助栈中都有体现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minData</span> = [<span class="title class_">Infinity</span>];<span class="comment">//定义辅助栈，初始存放Infinity</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(val);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minData</span>.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">this</span>.<span class="property">minData</span>[<span class="variable language_">this</span>.<span class="property">minData</span>.<span class="property">length</span>-<span class="number">1</span>],val));<span class="comment">//辅助栈存放辅助栈栈顶和入栈元素中较小的一个</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minData</span>.<span class="title function_">pop</span>();<span class="comment">//两个栈一起出栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMin</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">minData</span>[<span class="variable language_">this</span>.<span class="property">minData</span>.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(val)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.getMin()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h1><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p><h2 id="找左子树的最右节点"><a href="#找左子树的最右节点" class="headerlink" title="找左子树的最右节点"></a>找左子树的最右节点</h2><p>找root左子树的最右节点，将最右节点的right赋值为root的right，随后将最右节点的前驱节点赋给root的右节点，然后依次循环.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curr = root;<span class="comment">//将root节点赋给curr</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;<span class="comment">//循环条件curr不为空</span></span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="property">left</span> != <span class="literal">null</span>)&#123;<span class="comment">//如果curr有左节点</span></span><br><span class="line">            <span class="keyword">const</span> next = curr.<span class="property">left</span>;</span><br><span class="line">            <span class="keyword">let</span> predecessor = next;</span><br><span class="line">            <span class="keyword">while</span>(predecessor.<span class="property">right</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">                predecessor = predecessor.<span class="property">right</span>;<span class="comment">//寻找curr左节点的最右节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            predecessor.<span class="property">right</span> = curr.<span class="property">right</span>;<span class="comment">//将最右节点的右节点赋值为当前节点的右节点</span></span><br><span class="line">            curr.<span class="property">left</span> = <span class="literal">null</span>;<span class="comment">//将当前节点的左节点赋null</span></span><br><span class="line">            curr.<span class="property">right</span> = next;<span class="comment">//当前节点的右节点为当前节点的左节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.<span class="property">right</span>;<span class="comment">//将当前节点赋值为当前节点的右节点，依次循环下去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/356853/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/">114. 二叉树展开为链表 - 力扣（Leetcode）</a></p><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>先前序遍历树，将其每一个节点存入list顺序表。然后for循环，将root的每一个节点赋值为下一个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> list = [];</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">preorder</span> = (<span class="params">root,list</span>)=&gt;&#123;</span><br><span class="line">       <span class="keyword">if</span>(root)&#123;</span><br><span class="line">           list.<span class="title function_">push</span>(root);</span><br><span class="line">           <span class="title function_">preorder</span>(root.<span class="property">left</span>,list);</span><br><span class="line">           <span class="title function_">preorder</span>(root.<span class="property">right</span>,list);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">preorder</span>(root,list);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; list.<span class="property">length</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">let</span> prev = list[i - <span class="number">1</span>];<span class="comment">//第一次prev为root</span></span><br><span class="line">       <span class="keyword">let</span> next = list[i];<span class="comment">//next为左子树的第一个节点</span></span><br><span class="line">       prev.<span class="property">left</span> = <span class="literal">null</span>;<span class="comment">//将左节点赋值为空</span></span><br><span class="line">       prev.<span class="property">right</span> = next; <span class="comment">//右节点赋值为next</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h2 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> minpice = <span class="title class_">Infinity</span>;<span class="comment">//设置最小值</span></span><br><span class="line">        <span class="keyword">let</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minprofit)&#123;<span class="comment">//比较最小值</span></span><br><span class="line">                minprofit = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prices[i] - minpice &gt; maxprofit)&#123;<span class="comment">//当前天数减去最小金额则最大利润转换</span></span><br><span class="line">                maxprofit = prices[i] - minpice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h1><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = [];<span class="comment">//结果集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">str,open,close</span>) =&gt; &#123;<span class="comment">//三个参数分别是括号组合，(的数量、)的数量</span></span><br><span class="line">        <span class="keyword">if</span>(close &gt; open || open &gt; n)    <span class="keyword">return</span>;<span class="comment">//如果)的数量大于(或)的数量大于n，则说明不是有效的括号组合，返回</span></span><br><span class="line">        <span class="keyword">if</span>(str.<span class="property">length</span> === <span class="number">2</span> * n)&#123;<span class="comment">//如果str的长度等于2倍的n，则说明括号有效，将其推入结果集</span></span><br><span class="line">             result.<span class="title function_">push</span>(str)</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;  ;</span><br><span class="line">        <span class="title function_">dfs</span>(str+<span class="string">&quot;(&quot;</span>,open+<span class="number">1</span>,close);<span class="comment">//递归左括号</span></span><br><span class="line">        <span class="title function_">dfs</span>(str+<span class="string">&quot;)&quot;</span>,open,close+<span class="number">1</span>);<span class="comment">//递归右括号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//初始str为空，open和close都为0</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试手撕题</title>
      <link href="/2023/03/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98/"/>
      <url>/2023/03/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><table><thead><tr><th></th><th align="left">概念</th><th>区别</th><th>场景</th></tr></thead><tbody><tr><td>防抖</td><td align="left">触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。</td><td>防抖只执行最后一次，若时间内多次触发则重新计算时间。</td><td>input 输入、 多次点击按钮</td></tr><tr><td>节流</td><td align="left">高频事件触发，但在 n 秒内只会执行一次，如果 n 秒内触发多次函数，只有一次生效</td><td>节流是按一定的时间规律执行</td><td>拖拽，页面滚动</td></tr></tbody></table><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src="https://img-blog.csdnimg.cn/67195cb158274e5f876e358657119449.png" alt="防抖"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer); <span class="comment">//当定时器还在的时候，清除定时器，让函数重新开始计时，直到到达指定时间后执行fn函数</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p><img src="https://img-blog.csdnimg.cn/14fcee30f3d74ef4841739a448e5f3ca.png" alt="节流"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="keyword">return</span>; <span class="comment">//当指定时间还没结束，则返回不让定时器中的函数执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="手写-apply、call-和-bind"><a href="#手写-apply、call-和-bind" class="headerlink" title="手写 apply、call 和 bind"></a>手写 apply、call 和 bind</h1><table><thead><tr><th>函数</th><th>接收的参数</th></tr></thead><tbody><tr><td>apply</td><td>apply 调用函数的同时，改变函数的 this 指向。第一个参数为想要 this 指向的对象，第二个参数为<font color="red">数组</font>，数组的 value 就是想传入函数的参数</td></tr><tr><td>call</td><td>call 调用函数的同时，改变函数的 this 指向。第一个参数为想要 this 指向的对象，后面的为<font color="red">一个或多个参数</font>，是传入调用函数的参数</td></tr><tr><td>bind</td><td>返回一个新的函数，新函数的 this 为 bind 的第一个参数，其余参数为新函数的参数</td></tr></tbody></table><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写的call方法卸载Function的原型上，这样每个函数都能访问到</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">  obj = obj || <span class="variable language_">window</span>; <span class="comment">//如果第一个参数为空，则让其指向window</span></span><br><span class="line">  <span class="keyword">const</span> newArg = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//参数从1开始，因为第0个参数为this</span></span><br><span class="line">    newArg.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  obj.<span class="property">p</span> = <span class="variable language_">this</span>; <span class="comment">//其中这里的this就是调用myCall的函数，给obj对象添加函数p，p = 调用myCall的函数</span></span><br><span class="line">  <span class="keyword">let</span> result = obj.<span class="title function_">p</span>(...newArg); <span class="comment">//使用拓展运算符将1以后的参数传给函数p,并用result接收函数p的返回值</span></span><br><span class="line">  <span class="keyword">delete</span> obj.<span class="property">p</span>; <span class="comment">//因为原本的obj中并没有p这个函数，所以运行完后要把它删除</span></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">//返回函数执行的结果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">obj, arg</span>) &#123;</span><br><span class="line">  obj = obj || <span class="variable language_">window</span>; <span class="comment">//如果obj为空就让它指向window</span></span><br><span class="line">  <span class="keyword">const</span> newArg = [];</span><br><span class="line">  obj.<span class="property">p</span> = <span class="variable language_">this</span>; <span class="comment">//这里的this就是调用myApply的函数，给obj添加p这个方法，此时p = 调用myApply的函数</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//因为apply接收两个参数，第一个为this，第二个为数组参数，所以判断有无数组参数</span></span><br><span class="line">  <span class="keyword">if</span> (!arg) &#123;</span><br><span class="line">    result = obj.<span class="title function_">p</span>(); <span class="comment">//没有直接调用，并用result接收p的返回值，也就是调用myApply的函数的返回值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arg.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      newArg.<span class="title function_">push</span>(arg[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    result = obj.<span class="title function_">p</span>(...newArg); <span class="comment">//有，则将参数传给p再调用，并用result接收p的返回值，也就是调用myApply的函数的返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> obj.<span class="property">p</span>; <span class="comment">//结束后删掉obj中的p</span></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">//返回返回值，如果没有则返回的是null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span> || <span class="variable language_">window</span>; <span class="comment">//这里的this就是指向调用myBind的函数</span></span><br><span class="line">  <span class="keyword">let</span> arg = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>); <span class="comment">//使用Array.prototype.slice.call可以将arguments类数组转为数组。因为slice能返回一个新数组。这里也可以用Array.from将arguments转为数组。</span></span><br><span class="line">  <span class="keyword">let</span> _this = arg.<span class="title function_">shift</span>(); <span class="comment">//使用数组的队列方法shift，它能取出数组的第一个值并且返回它。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(_this, arg); <span class="comment">//返回fn的返回值，如果没有则会返回undefined</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array.prototype.slice将类数组转为数组的关键</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span> = <span class="keyword">function</span> (<span class="params">start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">  start = start || <span class="number">0</span>;</span><br><span class="line">  end = end || <span class="variable language_">this</span>.<span class="property">length</span>; <span class="comment">// this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><h2 id="什么是-instanceof"><a href="#什么是-instanceof" class="headerlink" title="什么是 instanceof"></a>什么是 instanceof</h2><p>MDN 解释：**<code>instanceof</code>** <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。只要处在同一条原型链上，就会返回 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student继承了Person，所以Student()是Person()的实例，Student的prototype的__proto__指向的是Person的prototype，而Person是Object()的实例，Person的prototype的__proto__指向的是Object的prototype</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age, hobby</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hobby</span> = hobby;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时也可以用构造函数的写法实现继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, hobby</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age); <span class="comment">//使用call改变Person的this，并传参调用Person</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = hobby;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//使用new Person创建Person的实例对象赋给Student的prototype对象</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>; <span class="comment">//修正Student原型的constructor，因为此时Student.prototype为Person的实例对象，constructor指向的是Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以instanceof就是用来判断该实例在不在原型链上的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student <span class="keyword">instanceof</span> <span class="title class_">Student</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span> <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="手写-instanceof"><a href="#手写-instanceof" class="headerlink" title="手写 instanceof"></a>手写 instanceof</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的obj1是代表实例对象，obj2代表构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">obj1, obj2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> objProto = obj1.<span class="property">__proto__</span>; <span class="comment">//将实例的隐式原型__proto__取出来进入循环</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (objProto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果objProto为null，则说明原型链到了尽头也没找到对应关系</span></span><br><span class="line">    <span class="keyword">if</span> (objProto === obj2.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="comment">//如果objProto与obj2构造函数的原型相等，则说明它们是继承关系</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    objProto = objProto.<span class="property">__proto__</span>; <span class="comment">//如果不相等，则往上寻找，让objProto等于它__proto__的__proto__，继续进行判断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS手撕题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记</title>
      <link href="/2023/03/07/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/07/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><p>git是免费、开源的<strong>分布式版本控制工具</strong>，可以快速高效地处理从小型到大型地各种项目。</p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li>代码推送 push</li><li>代码拉取 pull</li><li>代码克隆 clone</li><li>SSH免密登录</li></ul><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制就是一种<strong>记录文件内容变化</strong>、以便将来查阅特定版本修订情况的系统。</p><p>版本控制最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><h2 id="代码托管中心"><a href="#代码托管中心" class="headerlink" title="代码托管中心"></a>代码托管中心</h2><p>代码托管中心是基于网络服务器的远程代码仓库，一般简单成为<strong>远程库</strong></p><ul><li>局域网<ul><li>GitLab</li></ul></li><li>互联网<ul><li>GitHub（外网）</li><li>Gitee码云（国内）</li></ul></li></ul><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户邮箱</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名(git add . 添加当前目录下的所有文件)</td><td>将文件添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr></tbody></table><h3 id="设置用户签名和邮箱"><a href="#设置用户签名和邮箱" class="headerlink" title="设置用户签名和邮箱"></a>设置用户签名和邮箱</h3><p><code>git config --global user.name efohuajiao</code></p><p><code>git config --global user.email 3080680474@qq.com</code></p><p>签名的作用是区分不同操作者身份。用户的签名信息在每一个版本提交信息中能够看到，以此确认本次提交是水做的。$\textcolor{red}{GIt首次安装必须设置一下用户签名，否则无法提交代码。}$</p><p>$\textcolor{red}{注意:}$这里设置用户签名和将来登录GitHub的账号没有任何关系</p><h3 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h3><p>在需要设置仓库的文件路径下输入<code>git init</code>即可初始化本地库。</p><h3 id="查看本地库状态"><a href="#查看本地库状态" class="headerlink" title="查看本地库状态"></a>查看本地库状态</h3><p>使用<code>git status</code>即可查看本地库状态。</p><p><img src="http://cdn.t-terminal.icu/image-20230527142451296.png" alt="image-20230527142451296"></p><p>untracked files代表没有添加到暂存区的文件，git并没有追踪到，可以使用<code>git add 文件名</code>添加到暂存区。</p><p><img src="http://cdn.t-terminal.icu/image-20230527142704028.png" alt="image-20230527142704028"></p><h3 id="将文件从暂存区中删除"><a href="#将文件从暂存区中删除" class="headerlink" title="将文件从暂存区中删除"></a>将文件从暂存区中删除</h3><p><code>git rm --cached 文件名</code>即可把文件从暂存区中删除。<strong>只是从暂存区中删除，工作区中并没有删除。</strong></p><p><img src="http://cdn.t-terminal.icu/image-20230527143312843.png" alt="image-20230527143312843"></p><h3 id="提交到本地库"><a href="#提交到本地库" class="headerlink" title="提交到本地库"></a>提交到本地库</h3><p><code>git commit -m &quot;日志信息&quot;</code>即可将文件添加到本地库。</p><p><img src="http://cdn.t-terminal.icu/image-20230527143542405.png" alt="image-20230527143542405"></p><p>使用<code>git reflog</code>可以查看提交信息。其中<strong>fde23bf</strong>就是本次提交的版本信息。</p><p><img src="http://cdn.t-terminal.icu/image-20230527143611304.png" alt="image-20230527143611304"></p><p><code>git log</code>不仅可以看到提交信息，也可以看到提交者。</p><p><img src="http://cdn.t-terminal.icu/image-20230527143656927.png" alt="image-20230527143656927"></p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>如果文件在<strong>提交到本地库后经过修改</strong>，使用<code>git status</code>查看本地库状态时会显示修改后的文件，本地库状态会提示修改的文件。</p><p><img src="http://cdn.t-terminal.icu/image-20230527144150500.png" alt="image-20230527144150500"></p><p>这时就需要重新提交修改的文件到本地库，然后本地库就的版本就会指向最新的提交版本。</p><p><img src="http://cdn.t-terminal.icu/image-20230527144305126.png" alt="image-20230527144305126"></p><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><p><code>git reflog</code>可以查看版本信息。</p><p><code>git log</code>可以看到版本详细信息。</p><h4 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h4><p>步骤：</p><ol><li>通过<code>git reflog</code>查看版本号</li><li>使用<code>git reset --hard 版本号</code>即可跳转到对应的版本，文件也会回退到对应的版本。</li></ol><p><img src="http://cdn.t-terminal.icu/image-20230527145412428.png" alt="image-20230527145412428"></p><p><strong>git切换版本，底层其实是移动的HEAD指针</strong>。</p><p><img src="http://cdn.t-terminal.icu/image-20230527145529361.png" alt="image-20230527145529361"></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>在版本控制过程中，同时推进多个任务，为每个任务就可以创建单独的分支，使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。</p><h4 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h4><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><p><img src="http://cdn.t-terminal.icu/image-20230527151536894.png" alt="image-20230527151536894"></p><p>图中后面蓝色括号里的表示<strong>当前分支</strong>。</p><p><strong>$\textcolor{red}{每一个分支修改的文件仅在当前分支下有效，切换分支后，文件会变成对应分支的文件。}$</strong></p><p>hot-fix分支下的hello.txt文件。</p><img src="http://cdn.t-terminal.icu/image-20230527151917828.png" alt="image-20230527151917828" /><p>master分支下的hello.txt文件。</p><p><img src="http://cdn.t-terminal.icu/image-20230527152045684.png" alt="image-20230527152045684"></p><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p><strong>master是主分支，合并分支要在master分支下进行合并！！！</strong></p><p><code>git merge 分支名</code></p><p><img src="http://cdn.t-terminal.icu/image-20230527152314777.png" alt="image-20230527152314777"></p><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>合并分支时，两个分支，在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个，必须认为决定新代码内容。</p><p><img src="http://cdn.t-terminal.icu/image-20230527153641423.png" alt="image-20230527153641423"></p><p>这时就要人为修改文件，决定文件的内容。</p><p><img src="http://cdn.t-terminal.icu/image-20230527153729528.png" alt="image-20230527153729528"></p><p><img src="http://cdn.t-terminal.icu/image-20230527153807711.png" alt="image-20230527153807711"></p><p><img src="http://cdn.t-terminal.icu/image-20230527153833430.png" alt="image-20230527153833430"></p><h2 id="远程仓库操作（github为例）"><a href="#远程仓库操作（github为例）" class="headerlink" title="远程仓库操作（github为例）"></a>远程仓库操作（github为例）</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名，添加远程地址</td></tr><tr><td>git remote rm 别名</td><td>删除远程仓库</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h3 id="创建远程仓库别名"><a href="#创建远程仓库别名" class="headerlink" title="创建远程仓库别名"></a>创建远程仓库别名</h3><p>添加别名：<code>git remote add 别名 远程地址</code></p><p>查看别名：<code>git remote -v</code></p><p><img src="http://cdn.t-terminal.icu/image-20230527155943429.png" alt="image-20230527155943429"></p><h3 id="将本地库代码推送到远程库"><a href="#将本地库代码推送到远程库" class="headerlink" title="将本地库代码推送到远程库"></a>将本地库代码推送到远程库</h3><p><code>git push 别名 分支</code></p><p><img src="http://cdn.t-terminal.icu/image-20230527165708273.png" alt="image-20230527165708273"></p><h3 id="将远程库代码下载到本地库"><a href="#将远程库代码下载到本地库" class="headerlink" title="将远程库代码下载到本地库"></a>将远程库代码下载到本地库</h3><p><code>git pull 别名 分支</code></p><p><strong>获取到更新后的代码，使本地库代码与远程库代码同步。</strong></p><h3 id="克隆远程库代码"><a href="#克隆远程库代码" class="headerlink" title="克隆远程库代码"></a>克隆远程库代码</h3><p><code>git clone 远程库地址</code></p><p><strong>clone所做的事</strong></p><ol><li>拉取远程库的代码</li><li>初始化本地仓库</li><li>创建别名</li></ol><h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h3><p>需要添加成员后，成员才能对代码进行推送。</p><p><img src="http://cdn.t-terminal.icu/image-20230527171101146.png" alt="image-20230527171101146"></p><p><img src="http://cdn.t-terminal.icu/image-20230527171122873.png" alt="image-20230527171122873"></p><p><img src="http://cdn.t-terminal.icu/image-20230527171156033.png" alt="image-20230527171156033"></p><p>将随后生成的链接发给对方，<strong>对方同意后</strong>即可加入创作团队，进行代码推送。</p><h2 id="远程仓库操作（SSH）"><a href="#远程仓库操作（SSH）" class="headerlink" title="远程仓库操作（SSH）"></a>远程仓库操作（SSH）</h2><ol><li><p>创建SSH</p><p><code>ssh-keygen -t rsa -C github账号</code>即可生成ssh密钥。</p></li><li><p>在C盘用户目录下的.ssh文件夹中即可看到公钥和私钥。</p></li></ol><p><img src="http://cdn.t-terminal.icu/image-20230527172728606.png" alt="image-20230527172728606"></p><p><strong>.pub是公钥，复制公钥，在github中添加公钥。</strong></p><p><img src="http://cdn.t-terminal.icu/image-20230527172850431.png" alt="image-20230527172850431"></p><p><img src="http://cdn.t-terminal.icu/image-20230527172914098.png" alt="image-20230527172914098"></p><p><img src="http://cdn.t-terminal.icu/image-20230527172949732.png" alt="image-20230527172949732"></p><p><img src="http://cdn.t-terminal.icu/image-20230527173053059.png" alt="image-20230527173053059"></p><ol start="3"><li>随后即可<strong>通过SSH进行代码的拉取、推送等操作</strong></li></ol><p><img src="http://cdn.t-terminal.icu/image-20230527173129010.png" alt="image-20230527173129010"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS学习笔记</title>
      <link href="/2022/10/25/JS%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/25/JS%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h1><p>this就是一个指针变量，<strong>动态指向当前函数的运行环境</strong></p><h3 id="全局环境下的this"><a href="#全局环境下的this" class="headerlink" title="全局环境下的this"></a>全局环境下的this</h3><p>​全局作用域下，<strong>this永远指向window</strong>。</p><h3 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h3><ol><li><p>谁调用this就指向谁，没有调用，this就指向window</p></li><li><p>严格模式下，必须写上函数的调用者，不能省略或简写。全局中this的调用者是window。因此要写window.fn()。</p></li></ol><h3 id="对象中的this"><a href="#对象中的this" class="headerlink" title="对象中的this"></a>对象中的this</h3><p>对象内部方法的this指向调用这些方法的对象，也就是<strong>谁调用就指向谁</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is &quot;</span>+<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">obj</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">20</span>,</span><br><span class="line">        <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is &quot;</span>+<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayName</span>();<span class="comment">//张三。obj调用了sayName，所以此时this指向obj。</span></span><br><span class="line">obj.<span class="property">obj</span>.<span class="title function_">sayName</span>();<span class="comment">//李四。说明内部方法的this指向离被调用函数最近的对象。printChinese离grade对象近，所以this指向grade对象。</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>箭头函数没有自己的this，它的this<strong>在函数被定义时就已经被绑定</strong>，指向函数所在作用域的外部作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数中的this"><a href="#构造函数中的this" class="headerlink" title="构造函数中的this"></a>构造函数中的this</h3><p>构造函数中的this永远指向被创建的实例对象。如果构造函数中<strong>设置了具有对象的返回值</strong>，那么该对象就是new表达式的结果；如果返回值不是对象，则new表达式的结果为构造函数的实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fun = <span class="keyword">new</span> <span class="title class_">Fun</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">fun.<span class="title function_">sayName</span>();<span class="comment">//fun</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fun1</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">18</span>,<span class="attr">name</span>:<span class="string">&quot;李四&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fun1 = <span class="keyword">new</span> <span class="title class_">Fun1</span>(<span class="number">17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun1);<span class="comment">//&#123;a:18,name:&quot;李四&quot;&#125;,这里的fun1是构造函数返回的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun1.<span class="property">a</span>);<span class="comment">//18</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230402201900053.png" alt="image-20230402201900053"></p><h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><ol><li>定时器中的this</li></ol><p>​定时器中的回调为普通函数时，其中的this永远指向window，即全局环境。</p><p>​若为箭头函数时，它的this指向上一层的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">fun3</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;,<span class="number">100</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="attr">fun4</span>:<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;,<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fun3</span>();<span class="comment">//window</span></span><br><span class="line">obj.<span class="title function_">fun4</span>()<span class="comment">//obj</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230402202451062.png" alt="image-20230402202451062"></p><h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>当一个函数被创建时，JS会给他内部自动添加一个属性：prototype，prototype为一个对象，其中有一个constructor指向创建的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/.%5Cimages%5CJS%5C1685881682067.jpg" alt="image-20230401160332850"></p><p>可以看到fn的prototype属性中有constructor属性，可以将其看作指针，它指向的是fn这个函数。</p><h2 id="构造函数和实例对象"><a href="#构造函数和实例对象" class="headerlink" title="构造函数和实例对象"></a>构造函数和实例对象</h2><p>一般来说，函数名首字母大写的函数称为构造函数。使用<strong>new关键字</strong>可以通过构造函数定义一个它的实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">info</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">name</span>);<span class="comment">//张三</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">age</span>);<span class="comment">//18</span></span><br><span class="line">fn.<span class="title function_">info</span>()<span class="comment">//张三，18</span></span><br></pre></td></tr></table></figure><p>此时fn就是Fn的<strong>实例对象</strong>。</p><p>fn会继承在Fn的所有属性，在new的过程中，Fn中的this会自动指向fn，所以在new的过程中，JS做了以下事情。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.<span class="property">__proto__</span> = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="title function_">call</span>(fn);</span><br></pre></td></tr></table></figure><h2 id="proto-和prototype"><a href="#proto-和prototype" class="headerlink" title="______proto______和prototype"></a>______proto______和prototype</h2><p>在每个构造函数的实例对象中都有**____<strong>proto</strong><strong>属性,此时也可以把它当作一个</strong>指针**，它所指向的就是构造函数的prototype对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">__proto__</span> === <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure><p>此时fn就可以通过**____<strong>proto</strong><strong>获取Fn的</strong>prototype**原型上的所有属性。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>刚刚说到，通过**____<strong>proto</strong><strong>获取Fn的</strong>prototype<strong>原型上的所有属性,prototype也是一个实例对象，它是</strong>Object**的实例对象，因此在prototype中也有______proto__属性，它指向的是Object函数的原型对象，即Object的prototype原型对象。</p><p>既然prototype是一个实例对象，那么只要是实例对象，都会有一个**____<strong>proto</strong><strong>指向它的构造函数的原型对象。而Object的prototype的______proto______所指向的为</strong>null**。根据定义，null没有原型，因此原型链的尽头为Object.prototype.______proto__。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">info</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">__proto__</span> === <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)<span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>查找一个属性，实例对象会先在自身寻找，如果没有，会去它的______proto______也就是构造函数的prototype原型上找,如果也没有，则去构造函数的prototype的______proto__，也就是Object.prototype中去找，如果也没有，则返回undefined。</p><p>综上整个过程，即为原型链。</p><p><img src="/.%5Cimages%5CJS%5C1685882910590.jpg" alt="image-20230401193449120"></p><h2 id="Function、Object、function"><a href="#Function、Object、function" class="headerlink" title="Function、Object、function"></a>Function、Object、function</h2><p>其实在构造函数中，也有一个______proto__，这是为什么呢？</p><p>因为构造函数是函数，而所有函数都是Function的实例（包括Function本身），所以就会有一个很有意思的现象。Function的______proto__指向Function的prototype原型对象。</p><p>而Object也是一个构造函数，它的______proto__指向Function的prototype。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ff422e52ff0f49df80984d36ee01c719.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjUwNTg0NQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>将<strong>父类的实例</strong>赋给<strong>子类的原型</strong>，这样子类就可以获得父类的属性和方法，以及原型上的属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;person&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">get</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是Person的原型&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1.<span class="property">name</span>);</span><br><span class="line">stu1.<span class="title function_">get</span>();</span><br><span class="line">stu1.<span class="title function_">say</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1.<span class="property">friends</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">stu2.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu2.<span class="property">friends</span>);</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>可以继承父类及其原型的属性和方法</li></ol><p>缺点：</p><ol><li><strong>所有子类共享</strong>，一旦一个子类修改了父类的属性或方法，其他子类也会改变</li></ol><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>在子类中通过call或apply改变父类的this指向，调用父类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;person&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">get</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是Person的原型&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">friends</span>);</span><br><span class="line">stu.<span class="title function_">get</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu);</span><br><span class="line">stu.<span class="title function_">say</span>();</span><br></pre></td></tr></table></figure><p><img src="/.%5Cimages%5CJS%5C1685881577293.jpg"></p><p>优点：</p><ol><li>解决了原型链继承的缺点，每个子类继承的都是独一无二的父类，互不影响</li></ol><p>缺点：</p><ol><li><strong>无法继承父类原型链上的属性和方法</strong>，相当于在子类里<strong>调用了父类函数</strong>，给子类添加了父类的属性和方法</li><li>无法复用</li></ol><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用原型链继承和构造函数继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;person&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">get</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是Person的原型&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">friends</span>);</span><br><span class="line">stu.<span class="title function_">get</span>();</span><br><span class="line">stu.<span class="title function_">say</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu);</span><br></pre></td></tr></table></figure><p><img src="/.%5Cimages%5CJS%5C1685882113459.jpg"></p><p>优点</p><ol><li>解决了构造函数继承无法继承父类原型的问题，且子类继承的属性都是独立的，互不影响</li></ol><p>缺点</p><ol><li>会<strong>执行两次父类的构造函数</strong>，消耗较大内存</li></ol><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>利用一个新的函数Fn，将父类的实例赋给函数Fn的原型，然后子类中用call调用父类，并将Fn的实例赋给子类的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;person&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">get</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是Person的原型&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">friends</span>);</span><br><span class="line">stu.<span class="title function_">get</span>();</span><br><span class="line">stu.<span class="title function_">say</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu);</span><br></pre></td></tr></table></figure><p><img src="/.%5Cimages%5CJS%5C1685882731931.jpg"></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>本质就是内部函数引用的外部函数的变量或方法。</p><p>优点</p><ol><li>可以实现变量私有化，可以让变量不受污染</li></ol><p>缺点</p><ol><li>可能<strong>造成内存泄漏</strong></li></ol><h2 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h2><p><strong>每传递一个参数调用函数，就返回一个新函数处理剩余的参数</strong></p><p>柯里化的概念：<strong>接收一个函数</strong>fn，<strong>返回另一个函数</strong>curried，当curried中的<strong>参数少于</strong>fn时，它会<strong>返回另一个函数暂存之前的参数</strong>，直到<strong>参数个数等于fn接收的参数个数时返回结果</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>)&#123; <span class="comment">// 柯里化函数返回一个新的函数</span></span><br><span class="line">        <span class="keyword">if</span>(args.<span class="property">length</span> &lt; fn.<span class="property">length</span>)&#123; <span class="comment">// 如果调用返回的函数的参数少于fn本身的参数时,进入递归</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">curried</span>(...args.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>then函数是由返回值的，返回的是一个<strong>新的Promise对象实例化对象</strong>。</p><p>如果p1实例化对象是<strong>成功的状态</strong>，则<strong>执行then的成功回调函数</strong>；如果是<strong>失败</strong>的状态，则<strong>执行then的失败的回调函数</strong>。</p><p><strong>如果then中没有返回值</strong></p><ul><li>​then函数返回的Promise是<strong>成功</strong>的状态，并且<strong>结果值是undefined</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve(2)</span></span><br><span class="line">    <span class="comment">// reject(1)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;err&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Redmi\AppData\Roaming\Typora\typora-user-images\image-20230518193023372.png" alt="image-20230518193023372"></p><p><strong>如果then中有返回值</strong></p><ol><li>返回的为<strong>非Promise实例化对象</strong>，则<strong>状态仍是成功的Promise实例化对象</strong>，<strong>返回值就是结果值</strong></li><li>返回的为<strong>Promise实例化对象</strong>，则<strong>p2的状态取决于Promise实例化对象的状态</strong></li><li>如果<strong>直接抛出异常</strong>，则返回失败的Promise</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve(2)</span></span><br><span class="line">    <span class="comment">// reject(1)</span></span><br><span class="line">    <span class="comment">// throw &quot;err&quot;</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;okok&quot;</span>;<span class="comment">//p2的状态 [[PromiseState]]: &quot;fulfilled&quot;  [[PromiseResult]]: okok</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_,reject</span>)=&gt;</span>&#123; <span class="comment">//p2的状态 [[PromiseState]]: &quot;rejected&quot;  [[PromiseResult]]: 1</span></span><br><span class="line">         <span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;err&quot;</span>  <span class="comment">//p2的状态 [[PromiseState]]: &quot;rejected&quot;  [[PromiseResult]]: err</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//如果p2没有返回值，则p2的状态 [[PromiseState]]: &quot;fulfilled&quot;[[PromiseResult]]: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 === p2)<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>如果then中省略或者不是一个回调函数</strong></p><ul><li>默认成功的回调函数为<code>value =&gt; value</code>,默认失败的回调函数为<code>reason =&gt; &#123;throw reason&#125;</code></li></ul><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>catch用于捕捉Promise里reject后的值，和then一样也返回一个新的Promise。<strong>只有一个回调函数，表示失败的回调。</strong></p><p><strong>如果catch中没有返回值</strong></p><ul><li>​catch函数返回的Promise是<strong>成功</strong>的状态，并且<strong>结果值是undefined</strong>。</li></ul><p><strong>如果catch中有返回值</strong></p><ol><li>返回的为<strong>非Promise实例化对象</strong>，则<strong>状态仍是成功的Promise实例化对象</strong>，<strong>返回值就是结果值</strong></li><li>返回的为<strong>Promise实例化对象</strong>，则<strong>p2的状态取决于Promise实例化对象的状态</strong></li><li>如果<strong>直接抛出异常</strong>，则返回失败的Promise</li></ol><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p><code>Promise.resolve()</code>返回一个Promise。可以进行传参。</p><ol><li>参数为<strong>非Promise或为空</strong>： Promise状态为fulfilled，结果为传进的参数或undefined</li><li>参数为<strong>Promise的实例对象</strong>，则返回的Promise的状态取决于Promise实力对象的状态。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);<span class="comment">//PromiseState fulfilled PromiseResult undefined  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//PromiseState fulfilled PromiseResult 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//PromiseState fulfilled PromiseResult 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);<span class="comment">//PromiseState rejected PromiseResult error </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p4);<span class="comment">//PromiseState rejected PromiseResult &#x27;异常&#x27; </span></span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>不管参数如何，都返回一个失败的Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);<span class="comment">//PromiseState rejected PromiseResult undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//PromiseState rejected PromiseResult 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//PromiseState rejected PromiseResult Promise </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);<span class="comment">//PromiseState rejected PromiseResult Promise </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p4);<span class="comment">//PromiseState rejected PromiseResult Promise </span></span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>需要传递一个<strong>数组</strong>参数，数组里存的是<strong>Promise的实例化对象</strong>，<strong>返回值</strong>也是<strong>Promise的实例化对象</strong>。</p><h3 id="返回值的Promise状态"><a href="#返回值的Promise状态" class="headerlink" title="返回值的Promise状态"></a>返回值的Promise状态</h3><ol><li>当数组中所有的Promise实例化对象的状态<strong>都是成功</strong>的话，则返回的Promise的状态也是<strong>成功</strong>的，结果值为<strong>所有成功的Promise实例化对象的结果组成的数组</strong></li><li>当数组中所有的Promise实例化对象的状态<strong>有一个失败</strong>的话，<strong>直接返回失败的Promise实例化对象</strong>，<strong>结果值</strong>就是<strong>第一个失败Promise实例化对象的结果值</strong>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve(2)</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">MyPromise</span>.<span class="title function_">all</span>([p1,p2,p3]);<span class="comment">//PromiseState rejected PromiseResult 1 </span></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">MyPromise</span>.<span class="title function_">all</span>([p1,p2,p4]);<span class="comment">//PromiseState fulfilled PromiseResult [1,3,4] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>参数为一个<strong>由多个Promise实例对象组成的数组</strong>。</p><p>返回一个新的Promise实例对象，状态取决于数组中<strong>最先改变状态</strong>的Promise实例对象的<strong>状态为准</strong>。</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>当<code>new Promise</code>链式调用时，每调用一个then都会产生一个新的Promise，它的状态只要不是抛出异常<code>throw error</code>以及在then的回调里返回一个失败的Promise，它都会是一个成功的Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//1</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="literal">null</span>,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">//error</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">// 不输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="异常穿透"><a href="#异常穿透" class="headerlink" title="异常穿透"></a>异常穿透</h3><p>当Promise的链式调用时出现异常，那么它会一直往下，直到遇到能处理异常的回调(<strong>then中的onrejected回调或catch</strong>),在此期间，then返回的Promise状态都是rejected，直到异常处理后才变成fulfilled。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// reject(1)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;异常&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);<span class="comment">//PromiseState rejected PromiseResult ’异常‘</span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//不输出</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);<span class="comment">//PromiseState rejected PromiseResult ’异常‘</span></span><br><span class="line"><span class="keyword">const</span> p3 = p2.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//不输出</span></span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);<span class="comment">//异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);<span class="comment">//PromiseState fulfilled PromiseResult 1  </span></span><br><span class="line"><span class="keyword">const</span> p4 = p3.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p4);<span class="comment">//PromiseState fulfilled PromiseResult undefined </span></span><br></pre></td></tr></table></figure><h2 id="中断Promise链"><a href="#中断Promise链" class="headerlink" title="中断Promise链"></a>中断Promise链</h2><p>只要在链式调用的过程中<strong>返回一个pending状态的Promise</strong>，Promise链就会中断。因为pending状态的Promise并没有处理，then处理成功或者失败的Promise，catch处理失败的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p3 = p2.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p4 = p3.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//不输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="async函数和await表达式"><a href="#async函数和await表达式" class="headerlink" title="async函数和await表达式"></a>async函数和await表达式</h1><p>$\textcolor{red}{注意点：}$</p><ol><li>async函数中不一定要有await表达式，但有await的函数一定要有async</li><li>await相当于then，获取Promise实例对象成功的结果</li></ol><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>在函数前面加一个async就可以把该函数变为异步函数。</p><p>在函数内部正常书写，$\textcolor{red}{async函数的返回值为一个Promise}$ ,状态根据返回的数据决定。</p><ol><li>返回的是一个<strong>非Promise类型</strong>，那么状态为<strong>成功</strong>的Promise，结果为<strong>返回的具体值</strong>。</li><li>返回的是一个<strong>Promise实例对象</strong>，返回的Promise即为async函数返回的Promise。</li><li><strong>抛出异常</strong>，那么async也会返回一个<strong>失败的Promise</strong>，结果值为异常的值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="title function_">fn2</span>();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f3 = <span class="title function_">fn3</span>();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn4</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f4 = <span class="title function_">fn4</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1);<span class="comment">//PromiseState fulfilled PromiseResult 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2);<span class="comment">//PromiseState fulfilled PromiseResult 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f3);<span class="comment">//PromiseState rejected PromiseResult 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f4);<span class="comment">//PromiseState rejected PromiseResult &quot;异常&quot;</span></span><br></pre></td></tr></table></figure><h2 id="await（异步）"><a href="#await（异步）" class="headerlink" title="await（异步）"></a>await（异步）</h2><ol><li>如果await右侧为<strong>非Promise类型的数据</strong>，awiat后面<strong>是什么，得到的结果就是什么</strong></li><li>如果await右侧为<strong>成功的Promise</strong>，则得到的就是<strong>成功的结果</strong></li><li>如果await右侧为<strong>失败的Promise</strong>，需要用<strong>try…catch</strong>去捕获失败的结果</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn5</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(re);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn5</span>();<span class="comment">//null</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn6</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(re);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn6</span>();<span class="comment">//1</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn7</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="number">2</span>)<span class="comment">//失败的Promise需要用try...catch去捕获</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(re);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn7</span>();<span class="comment">//err</span></span><br></pre></td></tr></table></figure><h2 id="await执行顺序"><a href="#await执行顺序" class="headerlink" title="await执行顺序"></a>await执行顺序</h2><p>同步和异步同时存在时，会优先执行同步代码，随后再执行异步。<strong>await是异步的，它会等待后面的结果，哪怕是0秒也会等待。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> re1 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">await</span> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);<span class="comment">//await返回的是定时器的唯一标识符，timerId</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;re&quot;</span> + re);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//1 2 6 3 re4 5 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
